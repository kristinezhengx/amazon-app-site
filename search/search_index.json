{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shopping with Graphs: Learn Rising Graph Database Technology for Full-Stack Flutter Application Learn Graph Database Technology for Full-Stack Flutter Application Utilize TigerGraph\u2019s platform to showcase data relationships and application integration. Using an Amazon product reviews dataset, we will guide you through building a full stack application with graph technology. Graph databases, including TigerGraph, are used everyday for recommendations with internet searches, Netflix shows, and social media connections as well as fraud detection, customer360, IoT, AI and machine learning to make sense of ever-changing big data. These relational databases are extremely powerful for deep analytics with a flexible schema and scalability.","title":"Home"},{"location":"#shopping-with-graphs-learn-rising-graph-database-technology-for-full-stack-flutter-application","text":"","title":"Shopping with Graphs:  Learn Rising Graph Database Technology for Full-Stack Flutter Application"},{"location":"#learn-graph-database-technology-for-full-stack-flutter-application","text":"Utilize TigerGraph\u2019s platform to showcase data relationships and application integration. Using an Amazon product reviews dataset, we will guide you through building a full stack application with graph technology. Graph databases, including TigerGraph, are used everyday for recommendations with internet searches, Netflix shows, and social media connections as well as fraud detection, customer360, IoT, AI and machine learning to make sense of ever-changing big data. These relational databases are extremely powerful for deep analytics with a flexible schema and scalability.","title":"Learn Graph Database Technology for Full-Stack Flutter Application"},{"location":"conclusion/","text":"Awesome! We have completed our full stack Amazon Product Recommendation application utilizing TigerGraph and Flutter!","title":"Conclusion"},{"location":"dataworld/","text":"data.world: Amazon Product Data Data to use Unzip the Cleaned Amazon Product Review Data Process data.world Data source: Consumer Reviews of Amazon Products We selected this dataset of over 1500 consumer reviews for Amazon products including kindle, Fire TV stick. For each review, there is information about dates, ratings, reviews, and more. Pandas We used pandas to process and clean the amazon product data by removing unncessary columns and expanding lists as individual rows. Click this jupyter notebook to see the process.","title":"Data"},{"location":"dataworld/#dataworld-amazon-product-data","text":"","title":"data.world: Amazon Product Data"},{"location":"dataworld/#data-to-use","text":"Unzip the Cleaned Amazon Product Review Data","title":"Data to use"},{"location":"dataworld/#process","text":"","title":"Process"},{"location":"dataworld/#dataworld","text":"Data source: Consumer Reviews of Amazon Products We selected this dataset of over 1500 consumer reviews for Amazon products including kindle, Fire TV stick. For each review, there is information about dates, ratings, reviews, and more.","title":"data.world"},{"location":"dataworld/#pandas","text":"We used pandas to process and clean the amazon product data by removing unncessary columns and expanding lists as individual rows. Click this jupyter notebook to see the process.","title":"Pandas"},{"location":"middleware/","text":"Now that we have our environment set up, our TG solution established, and our queries installed and ready to be utilized, let's set up our middleware! Note: you should import our compressed graph before following the middleware and frontend steps so you have the exact schema and queries in the tutorial!! Connect to your TigerGraph Solution Open main.py in your middleware directory and import pyTigerGraph and configs. configs is going to be out configuration file for our TG solution credentials. import pyTigerGraph as tg import configs as Credential Now create a new configs.py file in the middle folder and import the TG credentials you created your solution with as shown below. HOST='https://flutter-app.i.tgcloud.io' USERNAME='tigergraph' PASSWORD='password' GRAPHNAME='productGraph' Back in the main.py file, create a connection to your TG Cloud server using pyTigerGraph. conn = tg.TigerGraphConnection(host=Credential.HOST, username=Credential.USERNAME, password=Credential.PASSWORD, graphname=Credential.GRAPHNAME) conn.apiToken = conn.getToken(conn.createSecret()) Check out the pyTigerGraph documentation . Save the main.py and configs.py files, and if it runs and reloads successfully, then you are connected to TG Cloud! Establish Cross-Origin Resource Sharing (CORS) Since a port is not specified, CORS configuration is essential. Import CORSMiddleware in the main.py file. from fastapi.middleware.cors import CORSMiddleware Create allowed origins (none in this case). origins = [\"*\"] Specify what the middleware allows: Credentials HTTP methods HTTP headers app.add_middleware( CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], ) Create Query Endpoints Let's first run the TigerGraph queries with FastAPI, starting with our userExists query. @app.get('/userExists') def userExists(user: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"userExists\", {\"id\": user})[0][\"Res\"] != [] return {\"res\": res} except: return {\"msg\": \"Uh oh! There's an error!\"} This runs the userExists query that was installed in GraphStudio. The query parameter takes the User ID, the output returns correctly if the user does exist, and returns nothin if the user does not exist. Test out the query call! Save the new changes in your main.py file and open 127.0.0.1:8000/docs , and click the drop down arrow to try out the userExists endpoint. Click the 'Try it out' button. Enter a valid user from the Amazon data and hit the 'Execute' button. If your input does not match any user from in the product data, you will get an error message returned to you. My go to is 'richard'. If you input 'richard', your result in the response body should be true. Let's now move to the Recommender Query. This requires a little bit more work. The data needs to be transformed into a nested tree in json format with keys like \"id\" or \"name\" and children of the list of objects that are associated with the keys. @app.get('/recommender') def recommender(user: Optional[str] = \"\"): try: gQuery = conn.runInstalledQuery(\"recommender\", {\"input\": user})[0][\"result\"] count = 0 children = [] for p in gQuery: children.append({ \"id\": str(count), \"name\": p[\"attributes\"][\"result.name\"], \"average rating\": p[\"attributes\"][\"result.@avgRating\"], \"num rating\": p[\"attributes\"][\"result.@numRating\"] }) count+=1 result = { \"children\": children, } return result except: return {\"msg\": \"Uh oh! There's an error!\"} Test out the Recommender endpoint the same way as the userExists query! Hit the drop down menu next to the endpoint name and execute a user name from the Amazon data. With a 200 success reponse, you should see the JSON format matches the key/children format we used in the code above. Complete Code Sample After implementing the productExists query, your completed main.py should look like this: from typing import Optional from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware import pyTigerGraph as tg import configs as Credential conn = tg.TigerGraphConnection(host=Credential.HOST, username=Credential.USERNAME, password=Credential.PASSWORD, graphname=Credential.GRAPHNAME) conn.apiToken = conn.getToken(conn.createSecret()) app = FastAPI() origins = [\"*\"] app.add_middleware( CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], ) @app.get('/userExists') def userExists(user: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"userExists\", {\"id\": user})[0][\"Res\"] != [] return {\"res\": res} except: return {\"msg\": \"Uh oh! There's an error!\"} @app.get('/productExists') def productExists(product: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"productExists\", {\"id\": product})[0][\"Res\"] return {\"res\": res[0][\"attributes\"]} except: return {\"msg\": \"Uh oh! There's an error!\"} @app.get('/recommender') def recommender(user: Optional[str] = \"\"): try: gQuery = conn.runInstalledQuery(\"recommender\", {\"input\": user})[0][\"result\"] count = 0 children = [] for p in gQuery: children.append({ \"id\": str(count), \"name\": p[\"attributes\"][\"result.name\"], \"average rating\": p[\"attributes\"][\"result.@avgRating\"], \"num rating\": p[\"attributes\"][\"result.@numRating\"] }) count+=1 result = { \"children\": children, } return result except: return {\"msg\": \"Uh oh! There's an error!\"} IMPORTANT NOTE : Don't forget that your TG solution should be started and running before API requests can be established through FastAPI and Flutter! Go to the TigerGraph Cloud page to set up your TG solution if you have not already done so.","title":"Middleware"},{"location":"middleware/#connect-to-your-tigergraph-solution","text":"Open main.py in your middleware directory and import pyTigerGraph and configs. configs is going to be out configuration file for our TG solution credentials. import pyTigerGraph as tg import configs as Credential Now create a new configs.py file in the middle folder and import the TG credentials you created your solution with as shown below. HOST='https://flutter-app.i.tgcloud.io' USERNAME='tigergraph' PASSWORD='password' GRAPHNAME='productGraph' Back in the main.py file, create a connection to your TG Cloud server using pyTigerGraph. conn = tg.TigerGraphConnection(host=Credential.HOST, username=Credential.USERNAME, password=Credential.PASSWORD, graphname=Credential.GRAPHNAME) conn.apiToken = conn.getToken(conn.createSecret()) Check out the pyTigerGraph documentation . Save the main.py and configs.py files, and if it runs and reloads successfully, then you are connected to TG Cloud!","title":"Connect to your TigerGraph Solution"},{"location":"middleware/#establish-cross-origin-resource-sharing-cors","text":"Since a port is not specified, CORS configuration is essential. Import CORSMiddleware in the main.py file. from fastapi.middleware.cors import CORSMiddleware Create allowed origins (none in this case). origins = [\"*\"] Specify what the middleware allows: Credentials HTTP methods HTTP headers app.add_middleware( CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], )","title":"Establish Cross-Origin Resource Sharing (CORS)"},{"location":"middleware/#create-query-endpoints","text":"Let's first run the TigerGraph queries with FastAPI, starting with our userExists query. @app.get('/userExists') def userExists(user: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"userExists\", {\"id\": user})[0][\"Res\"] != [] return {\"res\": res} except: return {\"msg\": \"Uh oh! There's an error!\"} This runs the userExists query that was installed in GraphStudio. The query parameter takes the User ID, the output returns correctly if the user does exist, and returns nothin if the user does not exist. Test out the query call! Save the new changes in your main.py file and open 127.0.0.1:8000/docs , and click the drop down arrow to try out the userExists endpoint. Click the 'Try it out' button. Enter a valid user from the Amazon data and hit the 'Execute' button. If your input does not match any user from in the product data, you will get an error message returned to you. My go to is 'richard'. If you input 'richard', your result in the response body should be true. Let's now move to the Recommender Query. This requires a little bit more work. The data needs to be transformed into a nested tree in json format with keys like \"id\" or \"name\" and children of the list of objects that are associated with the keys. @app.get('/recommender') def recommender(user: Optional[str] = \"\"): try: gQuery = conn.runInstalledQuery(\"recommender\", {\"input\": user})[0][\"result\"] count = 0 children = [] for p in gQuery: children.append({ \"id\": str(count), \"name\": p[\"attributes\"][\"result.name\"], \"average rating\": p[\"attributes\"][\"result.@avgRating\"], \"num rating\": p[\"attributes\"][\"result.@numRating\"] }) count+=1 result = { \"children\": children, } return result except: return {\"msg\": \"Uh oh! There's an error!\"} Test out the Recommender endpoint the same way as the userExists query! Hit the drop down menu next to the endpoint name and execute a user name from the Amazon data. With a 200 success reponse, you should see the JSON format matches the key/children format we used in the code above.","title":"Create Query Endpoints"},{"location":"middleware/#complete-code-sample","text":"After implementing the productExists query, your completed main.py should look like this: from typing import Optional from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware import pyTigerGraph as tg import configs as Credential conn = tg.TigerGraphConnection(host=Credential.HOST, username=Credential.USERNAME, password=Credential.PASSWORD, graphname=Credential.GRAPHNAME) conn.apiToken = conn.getToken(conn.createSecret()) app = FastAPI() origins = [\"*\"] app.add_middleware( CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], ) @app.get('/userExists') def userExists(user: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"userExists\", {\"id\": user})[0][\"Res\"] != [] return {\"res\": res} except: return {\"msg\": \"Uh oh! There's an error!\"} @app.get('/productExists') def productExists(product: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"productExists\", {\"id\": product})[0][\"Res\"] return {\"res\": res[0][\"attributes\"]} except: return {\"msg\": \"Uh oh! There's an error!\"} @app.get('/recommender') def recommender(user: Optional[str] = \"\"): try: gQuery = conn.runInstalledQuery(\"recommender\", {\"input\": user})[0][\"result\"] count = 0 children = [] for p in gQuery: children.append({ \"id\": str(count), \"name\": p[\"attributes\"][\"result.name\"], \"average rating\": p[\"attributes\"][\"result.@avgRating\"], \"num rating\": p[\"attributes\"][\"result.@numRating\"] }) count+=1 result = { \"children\": children, } return result except: return {\"msg\": \"Uh oh! There's an error!\"} IMPORTANT NOTE : Don't forget that your TG solution should be started and running before API requests can be established through FastAPI and Flutter! Go to the TigerGraph Cloud page to set up your TG solution if you have not already done so.","title":"Complete Code Sample"},{"location":"firebase/access/","text":"Now that everything has been setup and our images reside in our Cloud Firebase Storage, we are ready to implement code to access our images in our application! Configure Main File First, we must initialize Firebase when our app is run. In main.dart file, change your main() function to match below. Future<void> main() async { WidgetsFlutterBinding.ensureInitialized(); await Firebase.initializeApp(); runApp(MyApp()); } Implement on Product Page Next, we move to product_page.dart to add the Firebase package to the top of the code. import 'package:firebase_storage/firebase_storage.dart'; Then, we add a boolean variable to control when image populates under the _ProductPageState class variable. bool isButtonPressed = false; Now, a new function is created to get the image from the firebase instance. Future _getImage(BuildContext context, String imageName) async { String? downloadURL; downloadURL = await FirebaseStorage.instance.ref().child(imageName).getDownloadURL(); return downloadURL; } Now, inside the Container that handles the _productExists() functionalirty, we want to call our new _getImage() when our button is pressed. _productExists().then((result) { // ignore: unnecessary_null_comparison if (result.id != null) { setState(() { _productString = productController.text; _productName = (result.name); _productImgUrl = (result.imgURL); _getImage( context, \"test/\" + _productString + \".jpeg\"); print(_productString + \".jpeg\"); isButtonPressed = true; }); } else { setState(() { isVisible = true; _productName = \"This product does not exist!\"; }); } } Below that, we want to include the FutureBuilder that Connects to the Image Network to populate our image from the Firebase Storage URL that was created from the user input in the code above. if (isButtonPressed) FutureBuilder( future: _getImage(context, \"test/\" + _productString + \".jpeg\"), builder: (context, snapshot) { if (snapshot.hasError) { return const Text( \"Something went wrong\", ); } if (snapshot.connectionState == ConnectionState.done) { return Image.network( snapshot.data.toString(), ); } return const Center(child: CircularProgressIndicator()); }) Now that Firebase has been implemented, we will need to build the flutter app with a different command that deals with null safety handling. Use the below command to do so: $ flutter run -d chrome --no-sound-null-safety --web-renderer=html And voila! Firebase should be successfully implemented into our application! Now, when searching products, all of our images will successfully be populated from our Cloud Firebase Storage!","title":"Access Storage in Your Project"},{"location":"firebase/access/#configure-main-file","text":"First, we must initialize Firebase when our app is run. In main.dart file, change your main() function to match below. Future<void> main() async { WidgetsFlutterBinding.ensureInitialized(); await Firebase.initializeApp(); runApp(MyApp()); }","title":"Configure Main File"},{"location":"firebase/access/#implement-on-product-page","text":"Next, we move to product_page.dart to add the Firebase package to the top of the code. import 'package:firebase_storage/firebase_storage.dart'; Then, we add a boolean variable to control when image populates under the _ProductPageState class variable. bool isButtonPressed = false; Now, a new function is created to get the image from the firebase instance. Future _getImage(BuildContext context, String imageName) async { String? downloadURL; downloadURL = await FirebaseStorage.instance.ref().child(imageName).getDownloadURL(); return downloadURL; } Now, inside the Container that handles the _productExists() functionalirty, we want to call our new _getImage() when our button is pressed. _productExists().then((result) { // ignore: unnecessary_null_comparison if (result.id != null) { setState(() { _productString = productController.text; _productName = (result.name); _productImgUrl = (result.imgURL); _getImage( context, \"test/\" + _productString + \".jpeg\"); print(_productString + \".jpeg\"); isButtonPressed = true; }); } else { setState(() { isVisible = true; _productName = \"This product does not exist!\"; }); } } Below that, we want to include the FutureBuilder that Connects to the Image Network to populate our image from the Firebase Storage URL that was created from the user input in the code above. if (isButtonPressed) FutureBuilder( future: _getImage(context, \"test/\" + _productString + \".jpeg\"), builder: (context, snapshot) { if (snapshot.hasError) { return const Text( \"Something went wrong\", ); } if (snapshot.connectionState == ConnectionState.done) { return Image.network( snapshot.data.toString(), ); } return const Center(child: CircularProgressIndicator()); }) Now that Firebase has been implemented, we will need to build the flutter app with a different command that deals with null safety handling. Use the below command to do so: $ flutter run -d chrome --no-sound-null-safety --web-renderer=html And voila! Firebase should be successfully implemented into our application! Now, when searching products, all of our images will successfully be populated from our Cloud Firebase Storage!","title":"Implement on Product Page"},{"location":"firebase/initialize/","text":"Why Firebase Storage? Cloud Storage for Firebase is built for app developers who need to store and serve user-generated content, such as photos or videos. It is a cost-effective storage solution. The use of the Firebase SDKs allows us to store and upload images, audio, and other user-generated content, and the Google Cloud Storage APIs are used to access these files. For our use case, we'd like to store product images in the Cloud Storage which will be accessed through Flutter. Again, here is the Firebase documentation for getting started with web storage with Firebase. Getting start with Firebase Storage Let's begin by getting our Firebase storage ready! Go to your project dashboard on Firebase Console, select \u201cStorage\u201d from the left-hand menu then you can see the bucket path as shown in the screenshot below: I have created a folder called test to hold all the image files for this project. You don\u2019t have to manually add the path to your Flutter code because it will be handled automatically by Firebase packages. For simplicity\u2019s sake, we will NOT implement authentication in this example. Therefore, we need to change the rules for Firebase Storage to be public, like this:","title":"Initialize Storage"},{"location":"firebase/initialize/#why-firebase-storage","text":"Cloud Storage for Firebase is built for app developers who need to store and serve user-generated content, such as photos or videos. It is a cost-effective storage solution. The use of the Firebase SDKs allows us to store and upload images, audio, and other user-generated content, and the Google Cloud Storage APIs are used to access these files. For our use case, we'd like to store product images in the Cloud Storage which will be accessed through Flutter. Again, here is the Firebase documentation for getting started with web storage with Firebase.","title":"Why Firebase Storage?"},{"location":"firebase/initialize/#getting-start-with-firebase-storage","text":"Let's begin by getting our Firebase storage ready! Go to your project dashboard on Firebase Console, select \u201cStorage\u201d from the left-hand menu then you can see the bucket path as shown in the screenshot below: I have created a folder called test to hold all the image files for this project. You don\u2019t have to manually add the path to your Flutter code because it will be handled automatically by Firebase packages. For simplicity\u2019s sake, we will NOT implement authentication in this example. Therefore, we need to change the rules for Firebase Storage to be public, like this:","title":"Getting start with Firebase Storage"},{"location":"firebase/upload/","text":"Prior to uploading the images, they must be gathered first! To do so, I searched each product in our database and saved each from online. In a real use case, you should already have the image assets to upload. We can then hit the 'Upload File' button to add images to the selected folder. IMPORTANT NOTE: The name of each image you upload is very, very important! To correctly populate images based off user search and endpoint calls, each image should be names with the image id as shown below.","title":"Upload Images"},{"location":"frontend_pages/01_before/","text":"Before we begin building our flutter app, let's double check that our TG solution is still ready and running and that we can make the API calls through the FastAPI local doc site. All up and running? Perfect. Let's begin building our Flutter app!","title":"Before We Get Started"},{"location":"frontend_pages/02_dependency/","text":"To communicate with FastAPI, REST API requests must happen within Flutter. HTTP shall be utilized to do so. In your code editor, navigate to the tg_flutter directory and open the pubspec.yaml file. Located about line 29 are our app's dependencies. Add the http dependecy to your yaml file to make it look like it does below. We are also going to throw the firebase dependecies as well! You may or may not be prompted to update the dependencies. dependencies: http: ^0.13.4 url_launcher: ^6.0.18 firebase_core: ^1.6.3 cloud_firestore: ^1.0.4 firebase_storage: ^10.0.3 file_picker: ^4.0.3 flutter: sdk: flutter To update your dependencies use the following command from the tg_flutter folder. $ flutter pub get","title":"Dependency Changes"},{"location":"frontend_pages/03_exploring/","text":"It's time to explore the actual flutter code. Navigate to the lib folder within the tg_flutter folder. Open the main.dart file. A few important things to note about Flutter : For the initial starter code provided, all the code lives in the lib/main.dart file The app's UI is created with Dart code Almost everything is considered a widget. The app itself is a widget and the app's UI can be described as a widget tree So what is a Widget ? According to the Flutter Documentation, 'Widgets are the central class hierarchy in the Flutter framework. A widget is an immutable description of part of a user interface. Widgets can be inflated into elements, which manage the underlying render tree.' Stateful Widgets: a widget that stores info that can change, such as user input. Widgets themselves cannot be modified oonce created, so Flutter stores state information in a compantion class, the State class Learn more about the fundamentals of Flutter and the nuances of building a web app with Flutter here .","title":"Exploring Flutter Fundamentals"},{"location":"frontend_pages/03_exploring/#so-what-is-a-widget","text":"According to the Flutter Documentation, 'Widgets are the central class hierarchy in the Flutter framework. A widget is an immutable description of part of a user interface. Widgets can be inflated into elements, which manage the underlying render tree.' Stateful Widgets: a widget that stores info that can change, such as user input. Widgets themselves cannot be modified oonce created, so Flutter stores state information in a compantion class, the State class Learn more about the fundamentals of Flutter and the nuances of building a web app with Flutter here .","title":"So what is a Widget?"},{"location":"frontend_pages/04_laying/","text":"Now let\u2019s focus on transforming our starter code into a Recommender app for our Amazon product data! First, let\u2019s remove the starter code that was provided when we created the tg_flutter application. Before deleting anything, skim over the comments provided in the file. These are helpful to understanding each piece of the Flutter puzzle. Let\u2019s start with thinking about and laying down the foundation of our app\u2019s structure. What do our TigerGraph Queries look like? What information are we getting from each of them? And how do we display this information to the user? We have \u2018userExists\u2019, \u2018productExists\u2019, \u2018topProducts\u2019, and \u2018recommender\u2019. The user query and the recommender query have to do with User information and the input is a user name that exists in our data. So let\u2019s keep those two on one page! Let\u2019s put the product exists and top products queries on their own separate page. So now we know we must create multiple pages with navigation.","title":"Laying Down the Groundwork"},{"location":"frontend_pages/05_navigation/","text":"Creating navigation in Flutter is pretty straightforward. In Flutter, screens and pages are called routes. Create two routes, Navigate to the second route using Navigator.push(), and then return to the first route using Navigator.pop() and you will have two pages to display information! The Navigator.push() method adds a route to the stack of routes managed by navigator and the Navigator.pop() method removes the current route from the stack. In your empty main.dart file, paste the following code provided by the Flutter Navigation docs import 'package:flutter/material.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Amazon App', theme: ThemeData( primarySwatch: Colors.orange, visualDensity: VisualDensity.adaptivePlatformDensity, ), home: HomePage(), ); } } Then we want to create a folder within our lib directory called pages . This folder will hold the dart files containing the code for our content pages. Create three new dart files within this folder: home_page.dart , product_page.dart and user_page.dart . Paste the following code into each file, but change each of the 'HomePage' in the code to match the applicable file name. This is the basic skeleton and structure of each Flutter page. import 'package:flutter/material.dart'; class ProductPage extends StatefulWidget { ProductPage({Key? key}) : super(key: key); @override _ProductPageState createState() => _ProductPageState(); } class _ProductPageState extends State<ProductPage> { @override Widget build(BuildContext context) { return Scaffold(); } } We also want to create the controllers and a 'on clicked' function called _onItemTapped to control clicking on our Nav Bar. PageController _pageController = PageController(); List<Widget> _screen = [IntroPage(), UserPage(), ProductPage()]; int _selectedIndex = 0; void _onPageChanged(int index) { setState(() { _selectedIndex = index; }); } void _onItemTapped(int selectedIndex) { _pageController.jumpToPage(selectedIndex); } And then initialize! return Scaffold( body: PageView( controller: _pageController, children: _screen, onPageChanged: _onPageChanged, physics: NeverScrollableScrollPhysics(), ), Once you've made the appropriate changes to your code, save main.dart, open a terminal to the tg_flutter folder and run flutter run -d chrome`. A Chrome browser will automatically open and run assuming there are no errors. Here you will find the web application with the navigation bar. Here is the tutorial I watched to learn about the implementation of a Navbar in Flutter. The tutorial also gives more information about page persistence. I will not explain the exact implementation, but the please watch the tutorial as it is very helpful! And reference the code provided in the repo. Side Note: After you make changes to your main.dart file, if you hit r in the terminal that the terminal the flutter app is running from, it will hot restart the changes you made while the app is still running! The browser will just reload and your changes should appear as long as there are no errors.","title":"Navigation"},{"location":"frontend_pages/06_adding/","text":"Let's begin adding content to our application and start off with something simple, adding a gif to our intro page! Find your favorite gif online, copy the url, and let's display it from the web. The following line of code is a network call to display images from a url string. Image.network('https://example.com/animated-image.gif') Below is the code I included in the body of my intro_page.dart to display a TigerGraph inspired gif! child: Image.network('https://media2.giphy.com/media/dv7LVj1t6e1wobkYgX/giphy.gif?cid=ecf05e47zs97ng6h05arjp3l73ti4g0wyqr191cgy19bqoa4&rid=giphy.gif&ct=g', width: 300, height: 400, fit: BoxFit.contain, ),","title":"Adding to the Intro Page"},{"location":"frontend_pages/07_tigergraph/","text":"Now for the meat and potatoes of the project. We have already added the HTTP dependency to our pubspec.yml file, so we should be good to integrate the GET requests! First import HTTP into product_page.dart and user_page.dart like so: import 'package:http/http.dart' as http; import 'dart:async'; import 'dart:convert'; Building a User Class Let's begin with getting our User information in user_page.dart . We must first create a User class to contain what is returned from our userExists endpoint. class User { final bool success; User({ required this.success, }); factory User.fromJson(Map<String, dynamic> json) { return User( success: json['res'], ); } } Function Call Then, a function must be created to call the userExists endpoint within the _UserPageState class. Future<User> _userExists() async { final url = 'http://127.0.0.1:8000/userExists?user=$id'; final response = await http.get(Uri.parse(url)); if (response.statusCode == 200) { return User.fromJson(jsonDecode(response.body)); } else { throw Exception('Failed to load user'); } } Text Controllers Create some text controllers and variablesto get live changes to the inputs. TextEditingController idController = TextEditingController(); String id = \"\"; String _idString = 'Your user will appear here if it exists! '; bool isVisible = false; Update Widgets and their Containers In the body of our main widget, we will be including three Containers. These are nested in the body as a list of 'children'. body: Padding( padding: EdgeInsets.all(10), child: ListView(children: The first container is for the 'User Search' text above the search box. Container( alignment: Alignment.center, padding: const EdgeInsets.all(10), margin: const EdgeInsets.only(top: 50), child: const Text( 'User Search', style: TextStyle( color: Colors.orange, fontWeight: FontWeight.w500, fontSize: 30), )), The second container is for the actual search box that contains our text controller for our input. This is where the user of the application will search for a user name in our data to see if it exists. Container( padding: EdgeInsets.only(top: 10, left: 150, right: 150, bottom: 10), child: TextField( controller: idController, decoration: InputDecoration( border: OutlineInputBorder(), labelText: 'User ID', ), ), ), Now the next container will add the functionality of a user searching the input and populate with the response from the endpoint call. The below code does the following within the controller: set stat with our user id input text on button press, call our _userExists function, set our return string to input text IF the _userExists function returns the proper result, or else let the user of the application know that they did not input a user id that exists, update the input boxes. Container( height: 50, padding: EdgeInsets.only( top: 0, left: 150, right: 150, bottom: 10), child: RaisedButton( textColor: Colors.white, color: Colors.orange, child: Text('Search'), onPressed: () { print(idController.text); setState(() { id = idController.text; }); _userExists().then((result) { if (result.success) { print(\"SUCCESS\"); setState(() { _idString = idController.text; }); } else { setState(() { isVisible = true; _idString = \"The user you searched does not exist! Oops!\"; }); } }); }, )), The final container populates the text below the input box that follows 'User Name' with either the user name returned from the endpoint if it existed, or if a user name wasn't found, it will populate with a message letting the user know that the search was not successful. padding: const EdgeInsets.only( top: 0, left: 150, right: 150, bottom: 10), child: Column(children: [ Text( \"User Name: \" + _idString, style: const TextStyle(fontSize: 30), ), ]) ), Repeat for Recommender Endpoint It is a similar process for the other endpoints we have created, but there are some differences with the JSON parsing. The Recommender API call returns a list, so the JSON response must be handled differently. We must also create our Recommendation class a bit differently. Notive we have now included a toString method to handle the output of the instance of our new class. class Recommendation { final String id; final String name; final double avgRating; final int numRating; Recommendation( {required this.id, required this.name, required this.avgRating, required this.numRating}); factory Recommendation.fromJson(Map<String, dynamic> json) { return Recommendation( id: json['id'], name: json['name'], avgRating: json['average rating'], numRating: json['num rating']); } @override String toString() { return ''' Recommended ID: ${id} Product Name: ${name} Average Rating: ${avgRating} Number Rating: ${numRating} '''; } } The url response must be parsed and transformed into a list as well. Future<List<Recommendation>> _fetchRecommendations() async { final url = 'http://127.0.0.1:8000/recommender?user=$recommendedUser'; final response = await http.get(Uri.parse(url)); if (response.statusCode == 200) { var jsonResponse = json.decode(response.body)['children'] as List; return jsonResponse .map((recommendation) => Recommendation.fromJson(recommendation)) .toList(); } else { throw Exception('Failed to load recommendation'); } } And now to call the new _fetchRecommendations() function when our search button is pressed. onPressed: () { setState(() { recommendedUser = recommendationController.text; }); _fetchRecommendations().then((result) { // ignore: unnecessary_null_comparison if (result != null) { setState(() { _recommendationName = recommendationController.text; _recommendedProducts = result.join((\", \")).replaceAll(\",\", \"\"); }); } else { setState(() { isVisible = true; }); } }); }, ) Sample Input Utilize the below sample input to test the TigerGraph Functionality User IDs richard nash Johnnyblack llyyue Product IDs AVqVGZNvQMlgsOJE6eUY AWFUWc8THh53nbDRF6YO AVpftoij1cnluZ0-p5n2 AVpjEN4jLJeJML43rpUe JSON Resources Sample Input JSON parsing in Flutter was the most difficult concept for me to grasp, so below are a few resources that helped me understand it better: Background Parsing Dart Flutter Parse JSON String Array to Object List Now follow the code provided to add the product search and product recommendation for the product page.","title":"TigerGraph Functionality"},{"location":"frontend_pages/07_tigergraph/#building-a-user-class","text":"Let's begin with getting our User information in user_page.dart . We must first create a User class to contain what is returned from our userExists endpoint. class User { final bool success; User({ required this.success, }); factory User.fromJson(Map<String, dynamic> json) { return User( success: json['res'], ); } }","title":"Building a User Class"},{"location":"frontend_pages/07_tigergraph/#function-call","text":"Then, a function must be created to call the userExists endpoint within the _UserPageState class. Future<User> _userExists() async { final url = 'http://127.0.0.1:8000/userExists?user=$id'; final response = await http.get(Uri.parse(url)); if (response.statusCode == 200) { return User.fromJson(jsonDecode(response.body)); } else { throw Exception('Failed to load user'); } }","title":"Function Call"},{"location":"frontend_pages/07_tigergraph/#text-controllers","text":"Create some text controllers and variablesto get live changes to the inputs. TextEditingController idController = TextEditingController(); String id = \"\"; String _idString = 'Your user will appear here if it exists! '; bool isVisible = false;","title":"Text Controllers"},{"location":"frontend_pages/07_tigergraph/#update-widgets-and-their-containers","text":"In the body of our main widget, we will be including three Containers. These are nested in the body as a list of 'children'. body: Padding( padding: EdgeInsets.all(10), child: ListView(children: The first container is for the 'User Search' text above the search box. Container( alignment: Alignment.center, padding: const EdgeInsets.all(10), margin: const EdgeInsets.only(top: 50), child: const Text( 'User Search', style: TextStyle( color: Colors.orange, fontWeight: FontWeight.w500, fontSize: 30), )), The second container is for the actual search box that contains our text controller for our input. This is where the user of the application will search for a user name in our data to see if it exists. Container( padding: EdgeInsets.only(top: 10, left: 150, right: 150, bottom: 10), child: TextField( controller: idController, decoration: InputDecoration( border: OutlineInputBorder(), labelText: 'User ID', ), ), ), Now the next container will add the functionality of a user searching the input and populate with the response from the endpoint call. The below code does the following within the controller: set stat with our user id input text on button press, call our _userExists function, set our return string to input text IF the _userExists function returns the proper result, or else let the user of the application know that they did not input a user id that exists, update the input boxes. Container( height: 50, padding: EdgeInsets.only( top: 0, left: 150, right: 150, bottom: 10), child: RaisedButton( textColor: Colors.white, color: Colors.orange, child: Text('Search'), onPressed: () { print(idController.text); setState(() { id = idController.text; }); _userExists().then((result) { if (result.success) { print(\"SUCCESS\"); setState(() { _idString = idController.text; }); } else { setState(() { isVisible = true; _idString = \"The user you searched does not exist! Oops!\"; }); } }); }, )), The final container populates the text below the input box that follows 'User Name' with either the user name returned from the endpoint if it existed, or if a user name wasn't found, it will populate with a message letting the user know that the search was not successful. padding: const EdgeInsets.only( top: 0, left: 150, right: 150, bottom: 10), child: Column(children: [ Text( \"User Name: \" + _idString, style: const TextStyle(fontSize: 30), ), ]) ),","title":"Update Widgets and their Containers"},{"location":"frontend_pages/07_tigergraph/#repeat-for-recommender-endpoint","text":"It is a similar process for the other endpoints we have created, but there are some differences with the JSON parsing. The Recommender API call returns a list, so the JSON response must be handled differently. We must also create our Recommendation class a bit differently. Notive we have now included a toString method to handle the output of the instance of our new class. class Recommendation { final String id; final String name; final double avgRating; final int numRating; Recommendation( {required this.id, required this.name, required this.avgRating, required this.numRating}); factory Recommendation.fromJson(Map<String, dynamic> json) { return Recommendation( id: json['id'], name: json['name'], avgRating: json['average rating'], numRating: json['num rating']); } @override String toString() { return ''' Recommended ID: ${id} Product Name: ${name} Average Rating: ${avgRating} Number Rating: ${numRating} '''; } } The url response must be parsed and transformed into a list as well. Future<List<Recommendation>> _fetchRecommendations() async { final url = 'http://127.0.0.1:8000/recommender?user=$recommendedUser'; final response = await http.get(Uri.parse(url)); if (response.statusCode == 200) { var jsonResponse = json.decode(response.body)['children'] as List; return jsonResponse .map((recommendation) => Recommendation.fromJson(recommendation)) .toList(); } else { throw Exception('Failed to load recommendation'); } } And now to call the new _fetchRecommendations() function when our search button is pressed. onPressed: () { setState(() { recommendedUser = recommendationController.text; }); _fetchRecommendations().then((result) { // ignore: unnecessary_null_comparison if (result != null) { setState(() { _recommendationName = recommendationController.text; _recommendedProducts = result.join((\", \")).replaceAll(\",\", \"\"); }); } else { setState(() { isVisible = true; }); } }); }, )","title":"Repeat for Recommender Endpoint"},{"location":"frontend_pages/07_tigergraph/#sample-input","text":"Utilize the below sample input to test the TigerGraph Functionality User IDs richard nash Johnnyblack llyyue Product IDs AVqVGZNvQMlgsOJE6eUY AWFUWc8THh53nbDRF6YO AVpftoij1cnluZ0-p5n2 AVpjEN4jLJeJML43rpUe","title":"Sample Input"},{"location":"frontend_pages/07_tigergraph/#json-resources-sample-input","text":"JSON parsing in Flutter was the most difficult concept for me to grasp, so below are a few resources that helped me understand it better: Background Parsing Dart Flutter Parse JSON String Array to Object List Now follow the code provided to add the product search and product recommendation for the product page.","title":"JSON Resources Sample Input"},{"location":"setup/env/","text":"So to begin setting up our environment, let's start by creating a project folder in a desired location that will hold the contents of our project. Name it my-project . mkdir my-project cd my-project Flutter Now, to create a Flutter project, we first must fulfill the Flutter Requirements needed: Flutter SDK Chrome Optional: an IDE that supports Flutter. Visual Studio Code is used for this tutorial Follow the Building a Web Application with Flutter tutorial to get your machine set up with the Flutter SDK. IMPORTANT NOTE : The instructions provided by the Flutter Docs only sets your PATH variable for the current terminal window and not for future terminal windows. Follow these instructions to permanently add Flutter to your path. Create a new Flutter project with web support Run the following commands to get the latest version of Flutter flutter channel stable flutter upgrade And create and run a new Flutter project within the my-project directory. I named my flutter project tg_flutter . flutter create tg_flutter cd tg_flutter Serve your app from localhost in Chrome by running the following command from the main directory of the project, tg_flutter . flutter run -d chrome This launches the application using the development compiler in the Chrome browser. Middleware Requirements Python pip Create Middleware Directory In the my-project directory, create a new directory to hold the goods for the middleware. mkdir middleware cd middleware Your middleware and tg_flutter directories should sit next to each other in the my-project directory. Python Virtual Environment Create a virtual environment using venv and Python. python3 -m venv venv Activate the new virtual environment. source venv/bin/activate There should now be (venv) in front of your terminal after activating the virtual environment. Install Packages For the middleware, we will be using pyTigerGraph, FastAPI, and a library called uvicorn that is used by FastAPI pip install pyTigerGraph fastapi uvicorn What is FastAPI? FastAPI Setup Open the my-project directory in VS Code or your editor of choice, open the middleware folder, and create a file called main.py inside of it. Click into main.py and use code from FastAPI in that file. from typing import Optional from fastapi import FastAPI app = FastAPI() @app.get(\"/\") def read_root(): return {\"Hello\": \"World\"} Run the API Save main.py , open an integrated terminal in VS Code, and run the following command to run the API. uvicorn main:app --reload This is using uvicorn to run our file. The file name is main and the --reload has the server automatically reload after new changes are saved to the main.py file. Explore the Endpoints Now it's time to check out the endpoints that were just created! Enter https://127.0.0.1:8000 in a browser page, and here you should find the {\u201cHello\u201d: \u201cWorld\u201d} from the first function in the main.py file Enter http://127.0.0.1:8000/docs or http://127.0.0.1:8000/redoc to find interactive documentation for the endpoints we created. Thanks fastAPI! Firebase Sign into Firebase using your Google account and follow the linked Google documentation to get started! In this section, the specfiic SDKs will be configured for our project. Create Firebase Project Once you have Created your Firebase Project , you will be able to Register your project ! This is an example of my registration process: Click 'Create Project' Name your project Enable Google Analytics (optional) Click the final 'Create Project' once you have configured Google Analytics Click 'Continue' once you projected has finished provisioning Add a web app to your project by clicking the 'Web' icon from the Firebase console Give your app a nickname and enable hosting (optional), then click 'Register App' Add Firebase SDK IMPORTANT NOTE: Save the above SDK configuration information as it will be important in adding the SDKs to our Flutter project! Do not copy and paste what is above (it is just a dummy example), your configuration will be specific to your project and app. Install Firebase CLI (optional) Click 'Continue to Console' to finish adding the app to your project! Add Firebase SDKs The only way to currently add the Firebase SDKs to your Flutter web project is by importing the scripts from the Firebase content delivery network (CDN). Inside the tg_flutter project folder, located the index.html file. Add the firebase-app.js script to your index.html file within the <body> tag: <html> ... <body> <!-- Add these lines --> <script>window.flutterfire_web_sdk_version = '8.10.0';</script> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js\"></script> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-analytics.js\"></script> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js\"></script> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js\"></script> <!-- Add ^ lines --> <script src=\"main.dart.js\" type=\"application/javascript\"></script> </body> </html> Initializing Firebase The next step is to initialize Firebase using your project configuration. Create a new web app (or choose an existing one) on the Firebase Console and copy the configuration details. Initialize Firebase using these configuration details, placing the following script below the CDN imports added above: <html> ... <body> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js\"></script> ... <!-- Firebase Configuration --> <script> var firebaseConfig = { apiKey: \"...\", authDomain: \"[YOUR_PROJECT].firebaseapp.com\", databaseURL: \"https://[YOUR_PROJECT].firebaseio.com\", projectId: \"[YOUR_PROJECT]\", storageBucket: \"[YOUR_PROJECT].appspot.com\", messagingSenderId: \"...\", appId: \"1:...:web:...\", measurementId: \"G-...\", }; // Initialize Firebase firebase.initializeApp(firebaseConfig); </script> </body> </html> Once you've followed the Firebase setup documentation and implemented the above code, your environment should be setup to begin working with Firebase!","title":"Environment Setup"},{"location":"setup/env/#flutter","text":"Now, to create a Flutter project, we first must fulfill the Flutter Requirements needed: Flutter SDK Chrome Optional: an IDE that supports Flutter. Visual Studio Code is used for this tutorial Follow the Building a Web Application with Flutter tutorial to get your machine set up with the Flutter SDK. IMPORTANT NOTE : The instructions provided by the Flutter Docs only sets your PATH variable for the current terminal window and not for future terminal windows. Follow these instructions to permanently add Flutter to your path.","title":"Flutter"},{"location":"setup/env/#create-a-new-flutter-project-with-web-support","text":"Run the following commands to get the latest version of Flutter flutter channel stable flutter upgrade And create and run a new Flutter project within the my-project directory. I named my flutter project tg_flutter . flutter create tg_flutter cd tg_flutter Serve your app from localhost in Chrome by running the following command from the main directory of the project, tg_flutter . flutter run -d chrome This launches the application using the development compiler in the Chrome browser.","title":"Create a new Flutter project with web support"},{"location":"setup/env/#middleware","text":"Requirements Python pip","title":"Middleware"},{"location":"setup/env/#create-middleware-directory","text":"In the my-project directory, create a new directory to hold the goods for the middleware. mkdir middleware cd middleware Your middleware and tg_flutter directories should sit next to each other in the my-project directory.","title":"Create Middleware Directory"},{"location":"setup/env/#python-virtual-environment","text":"Create a virtual environment using venv and Python. python3 -m venv venv Activate the new virtual environment. source venv/bin/activate There should now be (venv) in front of your terminal after activating the virtual environment.","title":"Python Virtual Environment"},{"location":"setup/env/#install-packages","text":"For the middleware, we will be using pyTigerGraph, FastAPI, and a library called uvicorn that is used by FastAPI pip install pyTigerGraph fastapi uvicorn What is FastAPI?","title":"Install Packages"},{"location":"setup/env/#fastapi-setup","text":"Open the my-project directory in VS Code or your editor of choice, open the middleware folder, and create a file called main.py inside of it. Click into main.py and use code from FastAPI in that file. from typing import Optional from fastapi import FastAPI app = FastAPI() @app.get(\"/\") def read_root(): return {\"Hello\": \"World\"}","title":"FastAPI Setup"},{"location":"setup/env/#run-the-api","text":"Save main.py , open an integrated terminal in VS Code, and run the following command to run the API. uvicorn main:app --reload This is using uvicorn to run our file. The file name is main and the --reload has the server automatically reload after new changes are saved to the main.py file.","title":"Run the API"},{"location":"setup/env/#explore-the-endpoints","text":"Now it's time to check out the endpoints that were just created! Enter https://127.0.0.1:8000 in a browser page, and here you should find the {\u201cHello\u201d: \u201cWorld\u201d} from the first function in the main.py file Enter http://127.0.0.1:8000/docs or http://127.0.0.1:8000/redoc to find interactive documentation for the endpoints we created. Thanks fastAPI!","title":"Explore the Endpoints"},{"location":"setup/env/#firebase","text":"Sign into Firebase using your Google account and follow the linked Google documentation to get started! In this section, the specfiic SDKs will be configured for our project.","title":"Firebase"},{"location":"setup/env/#create-firebase-project","text":"Once you have Created your Firebase Project , you will be able to Register your project ! This is an example of my registration process: Click 'Create Project' Name your project Enable Google Analytics (optional) Click the final 'Create Project' once you have configured Google Analytics Click 'Continue' once you projected has finished provisioning Add a web app to your project by clicking the 'Web' icon from the Firebase console Give your app a nickname and enable hosting (optional), then click 'Register App' Add Firebase SDK IMPORTANT NOTE: Save the above SDK configuration information as it will be important in adding the SDKs to our Flutter project! Do not copy and paste what is above (it is just a dummy example), your configuration will be specific to your project and app. Install Firebase CLI (optional) Click 'Continue to Console' to finish adding the app to your project!","title":"Create Firebase Project"},{"location":"setup/env/#add-firebase-sdks","text":"The only way to currently add the Firebase SDKs to your Flutter web project is by importing the scripts from the Firebase content delivery network (CDN). Inside the tg_flutter project folder, located the index.html file. Add the firebase-app.js script to your index.html file within the <body> tag: <html> ... <body> <!-- Add these lines --> <script>window.flutterfire_web_sdk_version = '8.10.0';</script> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js\"></script> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-analytics.js\"></script> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js\"></script> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js\"></script> <!-- Add ^ lines --> <script src=\"main.dart.js\" type=\"application/javascript\"></script> </body> </html>","title":"Add Firebase SDKs"},{"location":"setup/env/#initializing-firebase","text":"The next step is to initialize Firebase using your project configuration. Create a new web app (or choose an existing one) on the Firebase Console and copy the configuration details. Initialize Firebase using these configuration details, placing the following script below the CDN imports added above: <html> ... <body> <script src=\"https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js\"></script> ... <!-- Firebase Configuration --> <script> var firebaseConfig = { apiKey: \"...\", authDomain: \"[YOUR_PROJECT].firebaseapp.com\", databaseURL: \"https://[YOUR_PROJECT].firebaseio.com\", projectId: \"[YOUR_PROJECT]\", storageBucket: \"[YOUR_PROJECT].appspot.com\", messagingSenderId: \"...\", appId: \"1:...:web:...\", measurementId: \"G-...\", }; // Initialize Firebase firebase.initializeApp(firebaseConfig); </script> </body> </html> Once you've followed the Firebase setup documentation and implemented the above code, your environment should be setup to begin working with Firebase!","title":"Initializing Firebase"},{"location":"setup/setup/","text":"Fundamentals to Downlaod Create a Github account if you don\u2019t already have one Install an IDE: we recommend vscode Make sure your computer has Python installed by typing the following in your mac terminal or windows powershell. python --version Visit Python documentation for more information. Optional Preparation: Review GSQL 101: Documentation TigerGraph Certification Continue to the Environment Setup to get started with TigerGraph, FastAPI, Flutter and Firebase!","title":"Basic Setup"},{"location":"setup/setup/#fundamentals-to-downlaod","text":"Create a Github account if you don\u2019t already have one Install an IDE: we recommend vscode Make sure your computer has Python installed by typing the following in your mac terminal or windows powershell. python --version Visit Python documentation for more information.","title":"Fundamentals to Downlaod"},{"location":"setup/setup/#optional-preparation","text":"Review GSQL 101: Documentation TigerGraph Certification Continue to the Environment Setup to get started with TigerGraph, FastAPI, Flutter and Firebase!","title":"Optional Preparation:"},{"location":"tgcloud/graphstudio/","text":"GraphStudio Graph Schema When your solution is done (pending tasks complete), hover over the symbols under actions to see the solutions operation icon and start your solution. Click the Applications icon and enter GraphStudio. You should be in the Global View. Click that name on the left and create a graph: we named ours ProductGraph. Design your graph schema based on the Amazon Product review data by adding vertex, edge types, and their corresponding attributes. For our purposes, be sure to click directed for edges between vertices so you can create the reverse edge at the same time. 4. Final schema! Remember to save! Map and Load Data Upload the cleaned data and check has header box and confirm the formatting. Hover over the symbols bar and click the arrows for \"map datafile to vertex or edge.\" Then you can start mapping the data corrresponding to graph vertex and edge information. Publish data mapping Click start and load data. Check if your stats look similar to ours: Explore Graph You can pick vertices to explore by type or id. Double click on a vertex to expand its edges and neighbor vertices. Hovering over a vertex or edge will review more details and attributes and click hide (crossed out eye) to clear your screen without deleting from your graph. Now you are all set with your graph schema! Move onto queries to analyze data and use your graph!","title":"GraphStudio"},{"location":"tgcloud/graphstudio/#graphstudio","text":"","title":"GraphStudio"},{"location":"tgcloud/graphstudio/#graph-schema","text":"When your solution is done (pending tasks complete), hover over the symbols under actions to see the solutions operation icon and start your solution. Click the Applications icon and enter GraphStudio. You should be in the Global View. Click that name on the left and create a graph: we named ours ProductGraph. Design your graph schema based on the Amazon Product review data by adding vertex, edge types, and their corresponding attributes. For our purposes, be sure to click directed for edges between vertices so you can create the reverse edge at the same time. 4. Final schema! Remember to save!","title":"Graph Schema"},{"location":"tgcloud/graphstudio/#map-and-load-data","text":"Upload the cleaned data and check has header box and confirm the formatting. Hover over the symbols bar and click the arrows for \"map datafile to vertex or edge.\" Then you can start mapping the data corrresponding to graph vertex and edge information. Publish data mapping Click start and load data. Check if your stats look similar to ours:","title":"Map and Load Data"},{"location":"tgcloud/graphstudio/#explore-graph","text":"You can pick vertices to explore by type or id. Double click on a vertex to expand its edges and neighbor vertices. Hovering over a vertex or edge will review more details and attributes and click hide (crossed out eye) to clear your screen without deleting from your graph. Now you are all set with your graph schema! Move onto queries to analyze data and use your graph!","title":"Explore Graph"},{"location":"tgcloud/importexport/","text":"Importing and exporting your solution Export If you wish to save your graph schema and queries as a compressed file, click export current solution. Import Click import an existing solution to import a compressed solution Note: you should import our compressed graph before following the middleware and frontend steps so you have the exact schema and queries in the tutorial!!","title":"Import and Export"},{"location":"tgcloud/importexport/#importing-and-exporting-your-solution","text":"","title":"Importing and exporting your solution"},{"location":"tgcloud/importexport/#export","text":"If you wish to save your graph schema and queries as a compressed file, click export current solution.","title":"Export"},{"location":"tgcloud/importexport/#import","text":"Click import an existing solution to import a compressed solution Note: you should import our compressed graph before following the middleware and frontend steps so you have the exact schema and queries in the tutorial!!","title":"Import"},{"location":"tgcloud/queries/","text":"Queries! After you finish creating your schema, mapping and loading data, and exploring, you are ready to use queries to analyze, update, and compute information from the graph! Move to the Write Queries part of the side bar to start. Read about TigerGraph's query documentation Relevant Examples: General Finds all products under certain category CREATE QUERY productWithCategory(STRING CatID) FOR GRAPH ProductGraph { prod = {Product.*}; // get all products into a set results = SELECT p FROM prod:p -(PRODUCT_HAS_CATEGORY)-> Category:c WHERE c.id == CatID; PRINT CatID, results; } Accumulators These next two queries uses accumulators, a special type of variables that gather information about the graph during its traversal and exploration. Recommends product by reviewer username and the categories of products they have reviewed. CREATE QUERY recommendProd(STRING username, int k) FOR GRAPH ProductGraph SYNTAX V2{ SetAccum<VERTEX> @@usedProd; prod = {Product.*}; vset1 = SELECT p FROM User:u-(USER_REVIEWS_PRODUCT>:e1)-prod:p-(PRODUCT_HAS_CATEGORY>:e2)-Category-(reverse_PRODUCT_HAS_CATEGORY>:e3)-prod:p WHERE u.id == username ACCUM @@usedProd += p; PRINT vset1; } Recommends products for a user based highest average rating and number of reviews. CREATE QUERY recommender(STRING username, int k) FOR GRAPH ProductGraph RETURNS (SET<VERTEX>) SYNTAX v2 { SetAccum<VERTEX> @@usedProd; AvgAccum @avgRating; SumAccum<INT> @numRating; prod = {Product.*}; vset1 = SELECT p FROM prod:p-(reverse_USER_REVIEWS_PRODUCT>:e)- User ACCUM p.@avgRating += e.rating, p.@numRating +=1; vset2 = SELECT p FROM User:u-(USER_REVIEWS_PRODUCT>:e1)-prod:p1-(PRODUCT_HAS_CATEGORY>:e2)-Category-(reverse_PRODUCT_HAS_CATEGORY>:e3)-vset1:p WHERE u.id == username ACCUM @@usedProd += p1; result = SELECT v FROM vset2:v-(reverse_USER_REVIEWS_PRODUCT>:e)-User Where v not in @@usedProd ORDER BY v.@avgRating DESC, v.@numRating DESC LIMIT k; PRINT result[result.name, result.@avgRating, result.@numRating]; RETURN result; }","title":"Queries"},{"location":"tgcloud/queries/#queries","text":"After you finish creating your schema, mapping and loading data, and exploring, you are ready to use queries to analyze, update, and compute information from the graph! Move to the Write Queries part of the side bar to start. Read about TigerGraph's query documentation","title":"Queries!"},{"location":"tgcloud/queries/#relevant-examples","text":"","title":"Relevant Examples:"},{"location":"tgcloud/queries/#general","text":"Finds all products under certain category CREATE QUERY productWithCategory(STRING CatID) FOR GRAPH ProductGraph { prod = {Product.*}; // get all products into a set results = SELECT p FROM prod:p -(PRODUCT_HAS_CATEGORY)-> Category:c WHERE c.id == CatID; PRINT CatID, results; }","title":"General"},{"location":"tgcloud/queries/#accumulators","text":"These next two queries uses accumulators, a special type of variables that gather information about the graph during its traversal and exploration. Recommends product by reviewer username and the categories of products they have reviewed. CREATE QUERY recommendProd(STRING username, int k) FOR GRAPH ProductGraph SYNTAX V2{ SetAccum<VERTEX> @@usedProd; prod = {Product.*}; vset1 = SELECT p FROM User:u-(USER_REVIEWS_PRODUCT>:e1)-prod:p-(PRODUCT_HAS_CATEGORY>:e2)-Category-(reverse_PRODUCT_HAS_CATEGORY>:e3)-prod:p WHERE u.id == username ACCUM @@usedProd += p; PRINT vset1; } Recommends products for a user based highest average rating and number of reviews. CREATE QUERY recommender(STRING username, int k) FOR GRAPH ProductGraph RETURNS (SET<VERTEX>) SYNTAX v2 { SetAccum<VERTEX> @@usedProd; AvgAccum @avgRating; SumAccum<INT> @numRating; prod = {Product.*}; vset1 = SELECT p FROM prod:p-(reverse_USER_REVIEWS_PRODUCT>:e)- User ACCUM p.@avgRating += e.rating, p.@numRating +=1; vset2 = SELECT p FROM User:u-(USER_REVIEWS_PRODUCT>:e1)-prod:p1-(PRODUCT_HAS_CATEGORY>:e2)-Category-(reverse_PRODUCT_HAS_CATEGORY>:e3)-vset1:p WHERE u.id == username ACCUM @@usedProd += p1; result = SELECT v FROM vset2:v-(reverse_USER_REVIEWS_PRODUCT>:e)-User Where v not in @@usedProd ORDER BY v.@avgRating DESC, v.@numRating DESC LIMIT k; PRINT result[result.name, result.@avgRating, result.@numRating]; RETURN result; }","title":"Accumulators"},{"location":"tgcloud/tgcloud/","text":"Setting up TGcloud Creating a Solution Create a free account on tgcloud.io if you don't already have one. Navigate to My Solutions and click Create Solution in the right corner. Note: you can only have one free tier solution at a time. Keep the default Blank kit and AWS platform. See the pictures below. Name your solution and subdomain, and set your password. This is what we wrote: Submit your solution!","title":"Cloud solution"},{"location":"tgcloud/tgcloud/#setting-up-tgcloud","text":"","title":"Setting up TGcloud"},{"location":"tgcloud/tgcloud/#creating-a-solution","text":"Create a free account on tgcloud.io if you don't already have one. Navigate to My Solutions and click Create Solution in the right corner. Note: you can only have one free tier solution at a time. Keep the default Blank kit and AWS platform. See the pictures below. Name your solution and subdomain, and set your password. This is what we wrote: Submit your solution!","title":"Creating a Solution"}]}