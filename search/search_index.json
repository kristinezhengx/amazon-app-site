{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shopping with Graphs: Learn Rising Graph Database Technology for Full-Stack Flutter Application Learn Graph Database Technology for Full-Stack Flutter Application Utilize TigerGraph\u2019s platform to showcase data relationships and application integration. Using an Amazon product reviews dataset, we will guide you through building a full stack application with graph technology. Graph databases, including TigerGraph, are used everyday for recommendations with internet searches, Netflix shows, and social media connections as well as fraud detection, customer360, IoT, AI and machine learning to make sense of ever-changing big data. These relational databases are extremely powerful for deep analytics with a flexible schema and scalability.","title":"Home"},{"location":"#shopping-with-graphs-learn-rising-graph-database-technology-for-full-stack-flutter-application","text":"","title":"Shopping with Graphs:  Learn Rising Graph Database Technology for Full-Stack Flutter Application"},{"location":"#learn-graph-database-technology-for-full-stack-flutter-application","text":"Utilize TigerGraph\u2019s platform to showcase data relationships and application integration. Using an Amazon product reviews dataset, we will guide you through building a full stack application with graph technology. Graph databases, including TigerGraph, are used everyday for recommendations with internet searches, Netflix shows, and social media connections as well as fraud detection, customer360, IoT, AI and machine learning to make sense of ever-changing big data. These relational databases are extremely powerful for deep analytics with a flexible schema and scalability.","title":"Learn Graph Database Technology for Full-Stack Flutter Application"},{"location":"conclusion/","text":"","title":"Conclusion"},{"location":"env/","text":"So to begin setting up our environment, let's start by creating a project folder in a desired location that will hold the contents of our project. Name it my-project . $ mkdir my-project $ cd my-project Flutter Now, to create a Flutter project, we first must fulfill the Flutter Requirements needed: Flutter SDK Chrome Optional: an IDE that supports Flutter. Visual Studio Code is used for this tutorial Follow the Building a Web Application with Flutter tutorial to get your machine set up with the Flutter SDK. IMPORTANT NOTE : The instructions provided by the Flutter Docs only sets your PATH variable for the current terminal window and not for future terminal windows. Follow these instructions to permanently add Flutter to your path. Create a new Flutter project with web support Run the following commands to get the latest version of Flutter $ flutter channel stable $ flutter upgrade And create and run a new Flutter project within the my-project directory. I named my flutter project tg_flutter . $ mkdir my-project $ cd my-project $ flutter create tg_flutter $ cd tg_flutter Serve your app from localhost in Chrome by running the following command from the main directory of the project, tg_flutter . $ flutter run -d chrome This launches the application using the development compiler in the Chrome browser. Middleware Requirements Python pip Create Middleware Directory In the my-project directory, create a new directory to hold the goods for the middleware. $ mkdir middleware $ cd middleware Your middleware and tg_flutter directories should sit next to each other in the my-project directory. Python Virtual Environment Create a virtual environment using venv and Python. $ python3 -m venv venv Activate the new virtual environment. $ source venv/bin/activate There should now be (venv) in front of your terminal after activating the virtual environment. Install Packages For the middleware, we will be using pyTigerGraph, FastAPI, and a library called uvicorn that is used by FastAPI $ pip install pyTigerGraph fastapi uvicorn What is FastAPI? FastAPI Setup Open the my-project directory in VS Code or your editor of choice, open the middleware folder, and create a file called main.py inside of it. Click into main.py and use code from FastAPI in that file. from typing import Optional from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } Run the API Save main.py , open an integrated terminal in VS Code, and run the following command to run the API. $ uvicorn main:app --reload This is using uvicorn to run our file. The file name is main and the --reload has the server automatically relaod after new changes are saved to the main.py file. Explore the Endpoints Now it's time to check out the endpoints that were just created! Enter https://127.0.0.1:8000 in a browser page, and here you should find the {\u201cHello\u201d: \u201cWorld\u201d} from the first function in the main.py file Enter http://127.0.0.1:8000/docs or http://127.0.0.1:8000/redoc to find interactive documentation for the endpoints we created. Thanks fastAPI! We will learn how to connect to our TigerGraph solution in the Middleware section. TigerGraph Cloud The Data Our data is coming from data.world The original dataset: Consumer reviews of Amazon products Manipulated data to fit our purposes can be found HERE inlcude link to data in github repo!!!","title":"Environment Setup"},{"location":"env/#flutter","text":"Now, to create a Flutter project, we first must fulfill the Flutter Requirements needed: Flutter SDK Chrome Optional: an IDE that supports Flutter. Visual Studio Code is used for this tutorial Follow the Building a Web Application with Flutter tutorial to get your machine set up with the Flutter SDK. IMPORTANT NOTE : The instructions provided by the Flutter Docs only sets your PATH variable for the current terminal window and not for future terminal windows. Follow these instructions to permanently add Flutter to your path.","title":"Flutter"},{"location":"env/#create-a-new-flutter-project-with-web-support","text":"Run the following commands to get the latest version of Flutter $ flutter channel stable $ flutter upgrade And create and run a new Flutter project within the my-project directory. I named my flutter project tg_flutter . $ mkdir my-project $ cd my-project $ flutter create tg_flutter $ cd tg_flutter Serve your app from localhost in Chrome by running the following command from the main directory of the project, tg_flutter . $ flutter run -d chrome This launches the application using the development compiler in the Chrome browser.","title":"Create a new Flutter project with web support"},{"location":"env/#middleware","text":"Requirements Python pip","title":"Middleware"},{"location":"env/#create-middleware-directory","text":"In the my-project directory, create a new directory to hold the goods for the middleware. $ mkdir middleware $ cd middleware Your middleware and tg_flutter directories should sit next to each other in the my-project directory.","title":"Create Middleware Directory"},{"location":"env/#python-virtual-environment","text":"Create a virtual environment using venv and Python. $ python3 -m venv venv Activate the new virtual environment. $ source venv/bin/activate There should now be (venv) in front of your terminal after activating the virtual environment.","title":"Python Virtual Environment"},{"location":"env/#install-packages","text":"For the middleware, we will be using pyTigerGraph, FastAPI, and a library called uvicorn that is used by FastAPI $ pip install pyTigerGraph fastapi uvicorn What is FastAPI?","title":"Install Packages"},{"location":"env/#fastapi-setup","text":"Open the my-project directory in VS Code or your editor of choice, open the middleware folder, and create a file called main.py inside of it. Click into main.py and use code from FastAPI in that file. from typing import Optional from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" }","title":"FastAPI Setup"},{"location":"env/#run-the-api","text":"Save main.py , open an integrated terminal in VS Code, and run the following command to run the API. $ uvicorn main:app --reload This is using uvicorn to run our file. The file name is main and the --reload has the server automatically relaod after new changes are saved to the main.py file.","title":"Run the API"},{"location":"env/#explore-the-endpoints","text":"Now it's time to check out the endpoints that were just created! Enter https://127.0.0.1:8000 in a browser page, and here you should find the {\u201cHello\u201d: \u201cWorld\u201d} from the first function in the main.py file Enter http://127.0.0.1:8000/docs or http://127.0.0.1:8000/redoc to find interactive documentation for the endpoints we created. Thanks fastAPI! We will learn how to connect to our TigerGraph solution in the Middleware section.","title":"Explore the Endpoints"},{"location":"env/#tigergraph-cloud","text":"","title":"TigerGraph Cloud"},{"location":"env/#the-data","text":"Our data is coming from data.world The original dataset: Consumer reviews of Amazon products Manipulated data to fit our purposes can be found HERE inlcude link to data in github repo!!!","title":"The Data"},{"location":"middleware/","text":"Now that we have our environment set up, our TG solution established, and our queries installed and ready to be utilized, let's set up our middleware! Connect to your TigerGraph Solution Open main.py in your middleware directory and import pyTigerGraph and configs. configs is going to be out configuration file for our TG solution credentials. import pyTigerGraph as tg import configs as Credential Now create a new configs.py file in the middle folder and import the TG credentials you created your solution with as shown below. HOST = 'https://flutter-app.i.tgcloud.io' USERNAME = 'tigergraph' PASSWORD = 'password' GRAPHNAME = 'productGraph' Back in the main.py file, create a connection to your TG Cloud server using pyTigerGraph. conn = tg . TigerGraphConnection ( host = Credential . HOST , username = Credential . USERNAME , password = Credential . PASSWORD , graphname = Credential . GRAPHNAME ) conn . apiToken = conn . getToken ( conn . createSecret ()) Check out the pyTigerGraph documentation . Save the main.py and configs.py files, and if it runs and reloads successfully, then you are connected to TG Cloud! Establish Cross-Origin Resource Sharing (CORS) Since a port is not specified, CORS configuration is essential. Import CORSMiddleware in the main.py file. from fastapi.middleware.cors import CORSMiddleware Create allowed origins (none in this case). origins = [ \"*\" ] Specify what the middleware allows: Credentials HTTP methods HTTP headers app . add_middleware ( CORSMiddleware , allow_origins = origins , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], ) Create Query Endpoints Let's first run the TigerGraph queries with FastAPI, starting with our userExists query. @app . get ( '/userExists' ) def userExists ( user : Optional [ str ] = \"\" ): try : res = conn . runInstalledQuery ( \"userExists\" , { \"id\" : user })[ 0 ][ \"Res\" ] != [] return { \"res\" : res } except : return { \"msg\" : \"Uh oh! There's an error!\" } This runs the userExists query that was installed in GraphStudio. The query parameter takes the User ID, the output returns correctly if the user does exist, and returns nothin if the user does not exist. Test out the query call! Save the new changes in your main.py file and open 127.0.0.1:8000/docs , and click the drop down arrow to try out the userExists endpoint. Click the 'Try it out' button. Enter a valid user from the Amazon data and hit the 'Execute' button. If your input does not match any user from in the product data, you will get an error message returned to you. My go to is 'richard'. If you input 'richard', your result in the response body should be true. Let's now move to the Recommender Query. This requires a little bit more work. The data needs to be transformed into a nested tree in json format with keys like \"id\" or \"name\" and children of the list of objects that are associated with the keys. @app . get ( '/recommender' ) def recommender ( user : Optional [ str ] = \"\" ): try : gQuery = conn . runInstalledQuery ( \"recommender\" , { \"input\" : user })[ 0 ][ \"result\" ] count = 0 children = [] for p in gQuery : children . append ({ \"id\" : str ( count ), \"name\" : p [ \"attributes\" ][ \"result.name\" ], \"average rating\" : p [ \"attributes\" ][ \"result.@avgRating\" ], \"num rating\" : p [ \"attributes\" ][ \"result.@numRating\" ] }) count += 1 result = { \"children\" : children , } return result except : return { \"msg\" : \"Uh oh! There's an error!\" } Test out the Recommender endpoint the same way as the userExists query! Hit the drop down menu next to the endpoint name and execute a user name from the Amazon data. With a 200 success reponse, you should see the JSON format matches the key/children format we used in the code above. Complete Code Sample After implementing the productExists query, your completed main.py should look like this: from typing import Optional from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware import pyTigerGraph as tg import configs as Credential conn = tg . TigerGraphConnection ( host = Credential . HOST , username = Credential . USERNAME , password = Credential . PASSWORD , graphname = Credential . GRAPHNAME ) conn . apiToken = conn . getToken ( conn . createSecret ()) app = FastAPI () origins = [ \"*\" ] app . add_middleware ( CORSMiddleware , allow_origins = origins , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], ) @app . get ( '/userExists' ) def userExists ( user : Optional [ str ] = \"\" ): try : res = conn . runInstalledQuery ( \"userExists\" , { \"id\" : user })[ 0 ][ \"Res\" ] != [] return { \"res\" : res } except : return { \"msg\" : \"Uh oh! There's an error!\" } @app . get ( '/productExists' ) def productExists ( product : Optional [ str ] = \"\" ): try : res = conn . runInstalledQuery ( \"productExists\" , { \"id\" : product })[ 0 ][ \"Res\" ] return { \"res\" : res [ 0 ][ \"attributes\" ]} except : return { \"msg\" : \"Uh oh! There's an error!\" } @app . get ( '/recommender' ) def recommender ( user : Optional [ str ] = \"\" ): try : gQuery = conn . runInstalledQuery ( \"recommender\" , { \"input\" : user })[ 0 ][ \"result\" ] count = 0 children = [] for p in gQuery : children . append ({ \"id\" : str ( count ), \"name\" : p [ \"attributes\" ][ \"result.name\" ], \"average rating\" : p [ \"attributes\" ][ \"result.@avgRating\" ], \"num rating\" : p [ \"attributes\" ][ \"result.@numRating\" ] }) count += 1 result = { \"children\" : children , } return result except : return { \"msg\" : \"Uh oh! There's an error!\" } IMPORTANT NOTE : Don't forget that your TG solution should be started and running before API requests can be established through FastAPI and Flutter! Go to the TigerGraph Cloud page to set up your TG solution if you have not already done so.","title":"Middleware"},{"location":"middleware/#connect-to-your-tigergraph-solution","text":"Open main.py in your middleware directory and import pyTigerGraph and configs. configs is going to be out configuration file for our TG solution credentials. import pyTigerGraph as tg import configs as Credential Now create a new configs.py file in the middle folder and import the TG credentials you created your solution with as shown below. HOST = 'https://flutter-app.i.tgcloud.io' USERNAME = 'tigergraph' PASSWORD = 'password' GRAPHNAME = 'productGraph' Back in the main.py file, create a connection to your TG Cloud server using pyTigerGraph. conn = tg . TigerGraphConnection ( host = Credential . HOST , username = Credential . USERNAME , password = Credential . PASSWORD , graphname = Credential . GRAPHNAME ) conn . apiToken = conn . getToken ( conn . createSecret ()) Check out the pyTigerGraph documentation . Save the main.py and configs.py files, and if it runs and reloads successfully, then you are connected to TG Cloud!","title":"Connect to your TigerGraph Solution"},{"location":"middleware/#establish-cross-origin-resource-sharing-cors","text":"Since a port is not specified, CORS configuration is essential. Import CORSMiddleware in the main.py file. from fastapi.middleware.cors import CORSMiddleware Create allowed origins (none in this case). origins = [ \"*\" ] Specify what the middleware allows: Credentials HTTP methods HTTP headers app . add_middleware ( CORSMiddleware , allow_origins = origins , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], )","title":"Establish Cross-Origin Resource Sharing (CORS)"},{"location":"middleware/#create-query-endpoints","text":"Let's first run the TigerGraph queries with FastAPI, starting with our userExists query. @app . get ( '/userExists' ) def userExists ( user : Optional [ str ] = \"\" ): try : res = conn . runInstalledQuery ( \"userExists\" , { \"id\" : user })[ 0 ][ \"Res\" ] != [] return { \"res\" : res } except : return { \"msg\" : \"Uh oh! There's an error!\" } This runs the userExists query that was installed in GraphStudio. The query parameter takes the User ID, the output returns correctly if the user does exist, and returns nothin if the user does not exist. Test out the query call! Save the new changes in your main.py file and open 127.0.0.1:8000/docs , and click the drop down arrow to try out the userExists endpoint. Click the 'Try it out' button. Enter a valid user from the Amazon data and hit the 'Execute' button. If your input does not match any user from in the product data, you will get an error message returned to you. My go to is 'richard'. If you input 'richard', your result in the response body should be true. Let's now move to the Recommender Query. This requires a little bit more work. The data needs to be transformed into a nested tree in json format with keys like \"id\" or \"name\" and children of the list of objects that are associated with the keys. @app . get ( '/recommender' ) def recommender ( user : Optional [ str ] = \"\" ): try : gQuery = conn . runInstalledQuery ( \"recommender\" , { \"input\" : user })[ 0 ][ \"result\" ] count = 0 children = [] for p in gQuery : children . append ({ \"id\" : str ( count ), \"name\" : p [ \"attributes\" ][ \"result.name\" ], \"average rating\" : p [ \"attributes\" ][ \"result.@avgRating\" ], \"num rating\" : p [ \"attributes\" ][ \"result.@numRating\" ] }) count += 1 result = { \"children\" : children , } return result except : return { \"msg\" : \"Uh oh! There's an error!\" } Test out the Recommender endpoint the same way as the userExists query! Hit the drop down menu next to the endpoint name and execute a user name from the Amazon data. With a 200 success reponse, you should see the JSON format matches the key/children format we used in the code above.","title":"Create Query Endpoints"},{"location":"middleware/#complete-code-sample","text":"After implementing the productExists query, your completed main.py should look like this: from typing import Optional from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware import pyTigerGraph as tg import configs as Credential conn = tg . TigerGraphConnection ( host = Credential . HOST , username = Credential . USERNAME , password = Credential . PASSWORD , graphname = Credential . GRAPHNAME ) conn . apiToken = conn . getToken ( conn . createSecret ()) app = FastAPI () origins = [ \"*\" ] app . add_middleware ( CORSMiddleware , allow_origins = origins , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], ) @app . get ( '/userExists' ) def userExists ( user : Optional [ str ] = \"\" ): try : res = conn . runInstalledQuery ( \"userExists\" , { \"id\" : user })[ 0 ][ \"Res\" ] != [] return { \"res\" : res } except : return { \"msg\" : \"Uh oh! There's an error!\" } @app . get ( '/productExists' ) def productExists ( product : Optional [ str ] = \"\" ): try : res = conn . runInstalledQuery ( \"productExists\" , { \"id\" : product })[ 0 ][ \"Res\" ] return { \"res\" : res [ 0 ][ \"attributes\" ]} except : return { \"msg\" : \"Uh oh! There's an error!\" } @app . get ( '/recommender' ) def recommender ( user : Optional [ str ] = \"\" ): try : gQuery = conn . runInstalledQuery ( \"recommender\" , { \"input\" : user })[ 0 ][ \"result\" ] count = 0 children = [] for p in gQuery : children . append ({ \"id\" : str ( count ), \"name\" : p [ \"attributes\" ][ \"result.name\" ], \"average rating\" : p [ \"attributes\" ][ \"result.@avgRating\" ], \"num rating\" : p [ \"attributes\" ][ \"result.@numRating\" ] }) count += 1 result = { \"children\" : children , } return result except : return { \"msg\" : \"Uh oh! There's an error!\" } IMPORTANT NOTE : Don't forget that your TG solution should be started and running before API requests can be established through FastAPI and Flutter! Go to the TigerGraph Cloud page to set up your TG solution if you have not already done so.","title":"Complete Code Sample"},{"location":"setup/","text":"Computer Setup Items to download Create a Github account if you don\u2019t already have one Install an IDE: we recommend vscode Make sure your computer has Python installed by typing the following in your mac terminal or windows powershell. Visit Python documentation for more information python -- version 4. Register for a TigerGraph cloud account 5. Install flutter? 6. Register or verify you have a Firebase account (connected to gmails) Optional preparation: 1. Review GSQL 101: * docs * videos","title":"Software setup"},{"location":"setup/#computer-setup","text":"","title":"Computer Setup"},{"location":"setup/#items-to-download","text":"Create a Github account if you don\u2019t already have one Install an IDE: we recommend vscode Make sure your computer has Python installed by typing the following in your mac terminal or windows powershell. Visit Python documentation for more information python -- version 4. Register for a TigerGraph cloud account 5. Install flutter? 6. Register or verify you have a Firebase account (connected to gmails) Optional preparation: 1. Review GSQL 101: * docs * videos","title":"Items to download"},{"location":"tgcloud/","text":"","title":"TigerGraph Cloud"},{"location":"frontend_pages/01_before/","text":"Before we begin building our flutter app, let's double check that our TG solution is still ready and running and that we can make the API calls through the FastAPI local doc site. All up and running? Perfect. Let's begin building our Flutter app!","title":"Before We Get Started"},{"location":"frontend_pages/02_dependency/","text":"To communicate with FastAPI, REST API requests must happen within Flutter. HTTP shall be utilized to do so. In your code editor, navigate to the tg_flutter directory and open the pubspec.yaml file. Located about line 29 are our app's dependencies. Add the http dependecy to your yaml file to make it look like it does below. You may or may not be prompted to update the dependencies. dependencies : http : ^0.13.4 url_launcher : ^6.0.18 flutter : sdk : flutter To update your dependencies use the following command from the tg_flutter folder. $ flutter pub get","title":"Dependency Changes"},{"location":"frontend_pages/03_exploring/","text":"It's time to explore the actual flutter code. Navigate to the lib folder within the tg_flutter folder. Open the main.dart file. A few important things to note about Flutter : For the initial starter code provided, all the code lives in the lib/main.dart file The app's UI is created with Dart code Almost everything is considered a widget. The app itself is a widget and the app's UI can be described as a widget tree So what is a Widget ? According to the Flutter Documentation, 'Widgets are the central class hierarchy in the Flutter framework. A widget is an immutable description of part of a user interface. Widgets can be inflated into elements, which manage the underlying render tree.' Stateful Widgets: a widget that stores info that can change, such as user input. Widgets themselves cannot be modified oonce created, so Flutter stores state information in a compantion class, the State class Learn more about the fundamentals of Flutter and the nuances of building a web app with Flutter here .","title":"Exploring Flutter Fundamentals"},{"location":"frontend_pages/03_exploring/#so-what-is-a-widget","text":"According to the Flutter Documentation, 'Widgets are the central class hierarchy in the Flutter framework. A widget is an immutable description of part of a user interface. Widgets can be inflated into elements, which manage the underlying render tree.' Stateful Widgets: a widget that stores info that can change, such as user input. Widgets themselves cannot be modified oonce created, so Flutter stores state information in a compantion class, the State class Learn more about the fundamentals of Flutter and the nuances of building a web app with Flutter here .","title":"So what is a Widget?"},{"location":"frontend_pages/04_laying/","text":"","title":"Laying Down the Groundwork"},{"location":"frontend_pages/05_navigation/","text":"","title":"Navigation"},{"location":"frontend_pages/06_adding/","text":"","title":"Adding to the Intro Page"},{"location":"frontend_pages/07_tigergraph/","text":"","title":"TigerGraph Functionality"}]}