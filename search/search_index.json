{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shopping with Graphs: Learn Rising Graph Database Technology for Full-Stack Flutter Application Learn Graph Database Technology for Full-Stack Flutter Application Utilize TigerGraph\u2019s platform to showcase data relationships and application integration. Using an Amazon product reviews dataset, we will guide you through building a full stack application with graph technology. Graph databases, including TigerGraph, are used everyday for recommendations with internet searches, Netflix shows, and social media connections as well as fraud detection, customer360, IoT, AI and machine learning to make sense of ever-changing big data. These relational databases are extremely powerful for deep analytics with a flexible schema and scalability.","title":"Home"},{"location":"#shopping-with-graphs-learn-rising-graph-database-technology-for-full-stack-flutter-application","text":"","title":"Shopping with Graphs:  Learn Rising Graph Database Technology for Full-Stack Flutter Application"},{"location":"#learn-graph-database-technology-for-full-stack-flutter-application","text":"Utilize TigerGraph\u2019s platform to showcase data relationships and application integration. Using an Amazon product reviews dataset, we will guide you through building a full stack application with graph technology. Graph databases, including TigerGraph, are used everyday for recommendations with internet searches, Netflix shows, and social media connections as well as fraud detection, customer360, IoT, AI and machine learning to make sense of ever-changing big data. These relational databases are extremely powerful for deep analytics with a flexible schema and scalability.","title":"Learn Graph Database Technology for Full-Stack Flutter Application"},{"location":"conclusion/","text":"Awesome! We have completed our full stack Amazon Product Recommendation application utilizing TigerGraph and Flutter!","title":"Conclusion"},{"location":"dataworld/","text":"data.world: Amazon Product Data Data to use Cleaned Amazon Product Review Process data.world Data source: Consumer Reviews of Amazon Products We selected this dataset of over 1500 consumer reviews for Amazon products including kindle, Fire TV stick. For each review, there is information about dates, ratings, reviews, and more. Pandas We used pandas to process and clean the amazon product data by removing unncessary columns and expanding lists as individual rows. Click this jupyter notebook name to see the process.","title":"Data"},{"location":"dataworld/#dataworld-amazon-product-data","text":"","title":"data.world: Amazon Product Data"},{"location":"dataworld/#data-to-use","text":"Cleaned Amazon Product Review","title":"Data to use"},{"location":"dataworld/#process","text":"","title":"Process"},{"location":"dataworld/#dataworld","text":"Data source: Consumer Reviews of Amazon Products We selected this dataset of over 1500 consumer reviews for Amazon products including kindle, Fire TV stick. For each review, there is information about dates, ratings, reviews, and more.","title":"data.world"},{"location":"dataworld/#pandas","text":"We used pandas to process and clean the amazon product data by removing unncessary columns and expanding lists as individual rows. Click this jupyter notebook name to see the process.","title":"Pandas"},{"location":"env/","text":"So to begin setting up our environment, let's start by creating a project folder in a desired location that will hold the contents of our project. Name it my-project . $ mkdir my-project $ cd my-project Flutter Now, to create a Flutter project, we first must fulfill the Flutter Requirements needed: Flutter SDK Chrome Optional: an IDE that supports Flutter. Visual Studio Code is used for this tutorial Follow the Building a Web Application with Flutter tutorial to get your machine set up with the Flutter SDK. IMPORTANT NOTE : The instructions provided by the Flutter Docs only sets your PATH variable for the current terminal window and not for future terminal windows. Follow these instructions to permanently add Flutter to your path. Create a new Flutter project with web support Run the following commands to get the latest version of Flutter $ flutter channel stable $ flutter upgrade And create and run a new Flutter project within the my-project directory. I named my flutter project tg_flutter . $ mkdir my-project $ cd my-project $ flutter create tg_flutter $ cd tg_flutter Serve your app from localhost in Chrome by running the following command from the main directory of the project, tg_flutter . $ flutter run -d chrome This launches the application using the development compiler in the Chrome browser. Middleware Requirements Python pip Create Middleware Directory In the my-project directory, create a new directory to hold the goods for the middleware. $ mkdir middleware $ cd middleware Your middleware and tg_flutter directories should sit next to each other in the my-project directory. Python Virtual Environment Create a virtual environment using venv and Python. $ python3 -m venv venv Activate the new virtual environment. $ source venv/bin/activate There should now be (venv) in front of your terminal after activating the virtual environment. Install Packages For the middleware, we will be using pyTigerGraph, FastAPI, and a library called uvicorn that is used by FastAPI $ pip install pyTigerGraph fastapi uvicorn What is FastAPI? FastAPI Setup Open the my-project directory in VS Code or your editor of choice, open the middleware folder, and create a file called main.py inside of it. Click into main.py and use code from FastAPI in that file. from typing import Optional from fastapi import FastAPI app = FastAPI() @app.get(\"/\") def read_root(): return {\"Hello\": \"World\"} Run the API Save main.py , open an integrated terminal in VS Code, and run the following command to run the API. $ uvicorn main:app --reload This is using uvicorn to run our file. The file name is main and the --reload has the server automatically relaod after new changes are saved to the main.py file. Explore the Endpoints Now it's time to check out the endpoints that were just created! Enter https://127.0.0.1:8000 in a browser page, and here you should find the {\u201cHello\u201d: \u201cWorld\u201d} from the first function in the main.py file Enter http://127.0.0.1:8000/docs or http://127.0.0.1:8000/redoc to find interactive documentation for the endpoints we created. Thanks fastAPI! We will learn how to connect to our TigerGraph solution in the Middleware section. TigerGraph Cloud The Data Our data is coming from data.world The original dataset: Consumer reviews of Amazon products Manipulated data to fit our purposes can be found HERE inlcude link to data in github repo!!!","title":"Environment Setup"},{"location":"env/#flutter","text":"Now, to create a Flutter project, we first must fulfill the Flutter Requirements needed: Flutter SDK Chrome Optional: an IDE that supports Flutter. Visual Studio Code is used for this tutorial Follow the Building a Web Application with Flutter tutorial to get your machine set up with the Flutter SDK. IMPORTANT NOTE : The instructions provided by the Flutter Docs only sets your PATH variable for the current terminal window and not for future terminal windows. Follow these instructions to permanently add Flutter to your path.","title":"Flutter"},{"location":"env/#create-a-new-flutter-project-with-web-support","text":"Run the following commands to get the latest version of Flutter $ flutter channel stable $ flutter upgrade And create and run a new Flutter project within the my-project directory. I named my flutter project tg_flutter . $ mkdir my-project $ cd my-project $ flutter create tg_flutter $ cd tg_flutter Serve your app from localhost in Chrome by running the following command from the main directory of the project, tg_flutter . $ flutter run -d chrome This launches the application using the development compiler in the Chrome browser.","title":"Create a new Flutter project with web support"},{"location":"env/#middleware","text":"Requirements Python pip","title":"Middleware"},{"location":"env/#create-middleware-directory","text":"In the my-project directory, create a new directory to hold the goods for the middleware. $ mkdir middleware $ cd middleware Your middleware and tg_flutter directories should sit next to each other in the my-project directory.","title":"Create Middleware Directory"},{"location":"env/#python-virtual-environment","text":"Create a virtual environment using venv and Python. $ python3 -m venv venv Activate the new virtual environment. $ source venv/bin/activate There should now be (venv) in front of your terminal after activating the virtual environment.","title":"Python Virtual Environment"},{"location":"env/#install-packages","text":"For the middleware, we will be using pyTigerGraph, FastAPI, and a library called uvicorn that is used by FastAPI $ pip install pyTigerGraph fastapi uvicorn What is FastAPI?","title":"Install Packages"},{"location":"env/#fastapi-setup","text":"Open the my-project directory in VS Code or your editor of choice, open the middleware folder, and create a file called main.py inside of it. Click into main.py and use code from FastAPI in that file. from typing import Optional from fastapi import FastAPI app = FastAPI() @app.get(\"/\") def read_root(): return {\"Hello\": \"World\"}","title":"FastAPI Setup"},{"location":"env/#run-the-api","text":"Save main.py , open an integrated terminal in VS Code, and run the following command to run the API. $ uvicorn main:app --reload This is using uvicorn to run our file. The file name is main and the --reload has the server automatically relaod after new changes are saved to the main.py file.","title":"Run the API"},{"location":"env/#explore-the-endpoints","text":"Now it's time to check out the endpoints that were just created! Enter https://127.0.0.1:8000 in a browser page, and here you should find the {\u201cHello\u201d: \u201cWorld\u201d} from the first function in the main.py file Enter http://127.0.0.1:8000/docs or http://127.0.0.1:8000/redoc to find interactive documentation for the endpoints we created. Thanks fastAPI! We will learn how to connect to our TigerGraph solution in the Middleware section.","title":"Explore the Endpoints"},{"location":"env/#tigergraph-cloud","text":"","title":"TigerGraph Cloud"},{"location":"env/#the-data","text":"Our data is coming from data.world The original dataset: Consumer reviews of Amazon products Manipulated data to fit our purposes can be found HERE inlcude link to data in github repo!!!","title":"The Data"},{"location":"middleware/","text":"Now that we have our environment set up, our TG solution established, and our queries installed and ready to be utilized, let's set up our middleware! Connect to your TigerGraph Solution Open main.py in your middleware directory and import pyTigerGraph and configs. configs is going to be out configuration file for our TG solution credentials. import pyTigerGraph as tg import configs as Credential Now create a new configs.py file in the middle folder and import the TG credentials you created your solution with as shown below. HOST='https://flutter-app.i.tgcloud.io' USERNAME='tigergraph' PASSWORD='password' GRAPHNAME='productGraph' Back in the main.py file, create a connection to your TG Cloud server using pyTigerGraph. conn = tg.TigerGraphConnection(host=Credential.HOST, username=Credential.USERNAME, password=Credential.PASSWORD, graphname=Credential.GRAPHNAME) conn.apiToken = conn.getToken(conn.createSecret()) Check out the pyTigerGraph documentation . Save the main.py and configs.py files, and if it runs and reloads successfully, then you are connected to TG Cloud! Establish Cross-Origin Resource Sharing (CORS) Since a port is not specified, CORS configuration is essential. Import CORSMiddleware in the main.py file. from fastapi.middleware.cors import CORSMiddleware Create allowed origins (none in this case). origins = [\"*\"] Specify what the middleware allows: Credentials HTTP methods HTTP headers app.add_middleware( CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], ) Create Query Endpoints Let's first run the TigerGraph queries with FastAPI, starting with our userExists query. @app.get('/userExists') def userExists(user: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"userExists\", {\"id\": user})[0][\"Res\"] != [] return {\"res\": res} except: return {\"msg\": \"Uh oh! There's an error!\"} This runs the userExists query that was installed in GraphStudio. The query parameter takes the User ID, the output returns correctly if the user does exist, and returns nothin if the user does not exist. Test out the query call! Save the new changes in your main.py file and open 127.0.0.1:8000/docs , and click the drop down arrow to try out the userExists endpoint. Click the 'Try it out' button. Enter a valid user from the Amazon data and hit the 'Execute' button. If your input does not match any user from in the product data, you will get an error message returned to you. My go to is 'richard'. If you input 'richard', your result in the response body should be true. Let's now move to the Recommender Query. This requires a little bit more work. The data needs to be transformed into a nested tree in json format with keys like \"id\" or \"name\" and children of the list of objects that are associated with the keys. @app.get('/recommender') def recommender(user: Optional[str] = \"\"): try: gQuery = conn.runInstalledQuery(\"recommender\", {\"input\": user})[0][\"result\"] count = 0 children = [] for p in gQuery: children.append({ \"id\": str(count), \"name\": p[\"attributes\"][\"result.name\"], \"average rating\": p[\"attributes\"][\"result.@avgRating\"], \"num rating\": p[\"attributes\"][\"result.@numRating\"] }) count+=1 result = { \"children\": children, } return result except: return {\"msg\": \"Uh oh! There's an error!\"} Test out the Recommender endpoint the same way as the userExists query! Hit the drop down menu next to the endpoint name and execute a user name from the Amazon data. With a 200 success reponse, you should see the JSON format matches the key/children format we used in the code above. Complete Code Sample After implementing the productExists query, your completed main.py should look like this: from typing import Optional from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware import pyTigerGraph as tg import configs as Credential conn = tg.TigerGraphConnection(host=Credential.HOST, username=Credential.USERNAME, password=Credential.PASSWORD, graphname=Credential.GRAPHNAME) conn.apiToken = conn.getToken(conn.createSecret()) app = FastAPI() origins = [\"*\"] app.add_middleware( CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], ) @app.get('/userExists') def userExists(user: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"userExists\", {\"id\": user})[0][\"Res\"] != [] return {\"res\": res} except: return {\"msg\": \"Uh oh! There's an error!\"} @app.get('/productExists') def productExists(product: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"productExists\", {\"id\": product})[0][\"Res\"] return {\"res\": res[0][\"attributes\"]} except: return {\"msg\": \"Uh oh! There's an error!\"} @app.get('/recommender') def recommender(user: Optional[str] = \"\"): try: gQuery = conn.runInstalledQuery(\"recommender\", {\"input\": user})[0][\"result\"] count = 0 children = [] for p in gQuery: children.append({ \"id\": str(count), \"name\": p[\"attributes\"][\"result.name\"], \"average rating\": p[\"attributes\"][\"result.@avgRating\"], \"num rating\": p[\"attributes\"][\"result.@numRating\"] }) count+=1 result = { \"children\": children, } return result except: return {\"msg\": \"Uh oh! There's an error!\"} IMPORTANT NOTE : Don't forget that your TG solution should be started and running before API requests can be established through FastAPI and Flutter! Go to the TigerGraph Cloud page to set up your TG solution if you have not already done so.","title":"Middleware"},{"location":"middleware/#connect-to-your-tigergraph-solution","text":"Open main.py in your middleware directory and import pyTigerGraph and configs. configs is going to be out configuration file for our TG solution credentials. import pyTigerGraph as tg import configs as Credential Now create a new configs.py file in the middle folder and import the TG credentials you created your solution with as shown below. HOST='https://flutter-app.i.tgcloud.io' USERNAME='tigergraph' PASSWORD='password' GRAPHNAME='productGraph' Back in the main.py file, create a connection to your TG Cloud server using pyTigerGraph. conn = tg.TigerGraphConnection(host=Credential.HOST, username=Credential.USERNAME, password=Credential.PASSWORD, graphname=Credential.GRAPHNAME) conn.apiToken = conn.getToken(conn.createSecret()) Check out the pyTigerGraph documentation . Save the main.py and configs.py files, and if it runs and reloads successfully, then you are connected to TG Cloud!","title":"Connect to your TigerGraph Solution"},{"location":"middleware/#establish-cross-origin-resource-sharing-cors","text":"Since a port is not specified, CORS configuration is essential. Import CORSMiddleware in the main.py file. from fastapi.middleware.cors import CORSMiddleware Create allowed origins (none in this case). origins = [\"*\"] Specify what the middleware allows: Credentials HTTP methods HTTP headers app.add_middleware( CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], )","title":"Establish Cross-Origin Resource Sharing (CORS)"},{"location":"middleware/#create-query-endpoints","text":"Let's first run the TigerGraph queries with FastAPI, starting with our userExists query. @app.get('/userExists') def userExists(user: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"userExists\", {\"id\": user})[0][\"Res\"] != [] return {\"res\": res} except: return {\"msg\": \"Uh oh! There's an error!\"} This runs the userExists query that was installed in GraphStudio. The query parameter takes the User ID, the output returns correctly if the user does exist, and returns nothin if the user does not exist. Test out the query call! Save the new changes in your main.py file and open 127.0.0.1:8000/docs , and click the drop down arrow to try out the userExists endpoint. Click the 'Try it out' button. Enter a valid user from the Amazon data and hit the 'Execute' button. If your input does not match any user from in the product data, you will get an error message returned to you. My go to is 'richard'. If you input 'richard', your result in the response body should be true. Let's now move to the Recommender Query. This requires a little bit more work. The data needs to be transformed into a nested tree in json format with keys like \"id\" or \"name\" and children of the list of objects that are associated with the keys. @app.get('/recommender') def recommender(user: Optional[str] = \"\"): try: gQuery = conn.runInstalledQuery(\"recommender\", {\"input\": user})[0][\"result\"] count = 0 children = [] for p in gQuery: children.append({ \"id\": str(count), \"name\": p[\"attributes\"][\"result.name\"], \"average rating\": p[\"attributes\"][\"result.@avgRating\"], \"num rating\": p[\"attributes\"][\"result.@numRating\"] }) count+=1 result = { \"children\": children, } return result except: return {\"msg\": \"Uh oh! There's an error!\"} Test out the Recommender endpoint the same way as the userExists query! Hit the drop down menu next to the endpoint name and execute a user name from the Amazon data. With a 200 success reponse, you should see the JSON format matches the key/children format we used in the code above.","title":"Create Query Endpoints"},{"location":"middleware/#complete-code-sample","text":"After implementing the productExists query, your completed main.py should look like this: from typing import Optional from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware import pyTigerGraph as tg import configs as Credential conn = tg.TigerGraphConnection(host=Credential.HOST, username=Credential.USERNAME, password=Credential.PASSWORD, graphname=Credential.GRAPHNAME) conn.apiToken = conn.getToken(conn.createSecret()) app = FastAPI() origins = [\"*\"] app.add_middleware( CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], ) @app.get('/userExists') def userExists(user: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"userExists\", {\"id\": user})[0][\"Res\"] != [] return {\"res\": res} except: return {\"msg\": \"Uh oh! There's an error!\"} @app.get('/productExists') def productExists(product: Optional[str] = \"\"): try: res = conn.runInstalledQuery(\"productExists\", {\"id\": product})[0][\"Res\"] return {\"res\": res[0][\"attributes\"]} except: return {\"msg\": \"Uh oh! There's an error!\"} @app.get('/recommender') def recommender(user: Optional[str] = \"\"): try: gQuery = conn.runInstalledQuery(\"recommender\", {\"input\": user})[0][\"result\"] count = 0 children = [] for p in gQuery: children.append({ \"id\": str(count), \"name\": p[\"attributes\"][\"result.name\"], \"average rating\": p[\"attributes\"][\"result.@avgRating\"], \"num rating\": p[\"attributes\"][\"result.@numRating\"] }) count+=1 result = { \"children\": children, } return result except: return {\"msg\": \"Uh oh! There's an error!\"} IMPORTANT NOTE : Don't forget that your TG solution should be started and running before API requests can be established through FastAPI and Flutter! Go to the TigerGraph Cloud page to set up your TG solution if you have not already done so.","title":"Complete Code Sample"},{"location":"setup/","text":"Computer Setup Items to download Create a Github account if you don\u2019t already have one Install an IDE: we recommend vscode Make sure your computer has Python installed by typing the following in your mac terminal or windows powershell. Visit Python documentation for more information py python --version 4. Register for a TigerGraph cloud account 5. Install flutter? 6. Register or verify you have a Firebase account (connected to gmails) Optional preparation: 1. Review GSQL 101: * docs * videos","title":"Software Setup"},{"location":"setup/#computer-setup","text":"","title":"Computer Setup"},{"location":"setup/#items-to-download","text":"Create a Github account if you don\u2019t already have one Install an IDE: we recommend vscode Make sure your computer has Python installed by typing the following in your mac terminal or windows powershell. Visit Python documentation for more information py python --version 4. Register for a TigerGraph cloud account 5. Install flutter? 6. Register or verify you have a Firebase account (connected to gmails) Optional preparation: 1. Review GSQL 101: * docs * videos","title":"Items to download"},{"location":"tgcloud/","text":"Setting up tgcloud","title":"TigerGraph Cloud"},{"location":"tgcloud/#setting-up-tgcloud","text":"","title":"Setting up tgcloud"},{"location":"frontend_pages/01_before/","text":"Before we begin building our flutter app, let's double check that our TG solution is still ready and running and that we can make the API calls through the FastAPI local doc site. All up and running? Perfect. Let's begin building our Flutter app!","title":"Before We Get Started"},{"location":"frontend_pages/02_dependency/","text":"To communicate with FastAPI, REST API requests must happen within Flutter. HTTP shall be utilized to do so. In your code editor, navigate to the tg_flutter directory and open the pubspec.yaml file. Located about line 29 are our app's dependencies. Add the http dependecy to your yaml file to make it look like it does below. You may or may not be prompted to update the dependencies. dependencies: http: ^0.13.4 url_launcher: ^6.0.18 flutter: sdk: flutter To update your dependencies use the following command from the tg_flutter folder. $ flutter pub get","title":"Dependency Changes"},{"location":"frontend_pages/03_exploring/","text":"It's time to explore the actual flutter code. Navigate to the lib folder within the tg_flutter folder. Open the main.dart file. A few important things to note about Flutter : For the initial starter code provided, all the code lives in the lib/main.dart file The app's UI is created with Dart code Almost everything is considered a widget. The app itself is a widget and the app's UI can be described as a widget tree So what is a Widget ? According to the Flutter Documentation, 'Widgets are the central class hierarchy in the Flutter framework. A widget is an immutable description of part of a user interface. Widgets can be inflated into elements, which manage the underlying render tree.' Stateful Widgets: a widget that stores info that can change, such as user input. Widgets themselves cannot be modified oonce created, so Flutter stores state information in a compantion class, the State class Learn more about the fundamentals of Flutter and the nuances of building a web app with Flutter here .","title":"Exploring Flutter Fundamentals"},{"location":"frontend_pages/03_exploring/#so-what-is-a-widget","text":"According to the Flutter Documentation, 'Widgets are the central class hierarchy in the Flutter framework. A widget is an immutable description of part of a user interface. Widgets can be inflated into elements, which manage the underlying render tree.' Stateful Widgets: a widget that stores info that can change, such as user input. Widgets themselves cannot be modified oonce created, so Flutter stores state information in a compantion class, the State class Learn more about the fundamentals of Flutter and the nuances of building a web app with Flutter here .","title":"So what is a Widget?"},{"location":"frontend_pages/04_laying/","text":"Now let\u2019s focus on transforming our starter code into a Recommender app for our Amazon product data! First, let\u2019s remove the starter code that was provided when we created the tg_flutter application. Before deleting anything, skim over the comments provided in the file. These are helpful to understanding each piece of the Flutter puzzle. Let\u2019s start with thinking about and laying down the foundation of our app\u2019s structure. What do our TigerGraph Queries look like? What information are we getting from each of them? And how do we display this information to the user? We have \u2018userExists\u2019, \u2018productExists\u2019, \u2018topProducts\u2019, and \u2018recommender\u2019. The user query and the recommender query have to do with User information and the input is a user name that exists in our data. So let\u2019s keep those two on one page! Let\u2019s put the product exists and top products queries on their own separate page. So now we know we must create multiple pages with navigation.","title":"Laying Down the Groundwork"},{"location":"frontend_pages/05_navigation/","text":"Creating navigation in Flutter is pretty straightforward. In Flutter, screens and pages are called routes. Create two routes, Navigate to the second route using Navigator.push(), and then return to the first route using Navigator.pop() and you will have two pages to display information! The Navigator.push() method adds a route to the stack of routes managed by navigator and the Navigator.pop() method removes the current route from the stack. In your empty main.dart file, paste the following code provided by the Flutter Navigation docs import 'package:flutter/material.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Amazon App', theme: ThemeData( primarySwatch: Colors.orange, visualDensity: VisualDensity.adaptivePlatformDensity, ), home: HomePage(), ); } } Then we want to create a folder within our lib directory called pages . This folder will hold the dart files containing the code for our content pages. Create three new dart files within this folder: home_page.dart , product_page.dart and user_page.dart . Paste the following code into each file, but change each of the 'HomePage' in the code to match the applicable file name. This is the basic skeleton and structure of each Flutter page. import 'package:flutter/material.dart'; class ProductPage extends StatefulWidget { ProductPage({Key? key}) : super(key: key); @override _ProductPageState createState() => _ProductPageState(); } class _ProductPageState extends State<ProductPage> { @override Widget build(BuildContext context) { return Scaffold(); } } We also want to create the controllers and a 'on clicked' function called _onItemTapped to control clicking on our Nav Bar. PageController _pageController = PageController(); List<Widget> _screen = [IntroPage(), UserPage(), ProductPage()]; int _selectedIndex = 0; void _onPageChanged(int index) { setState(() { _selectedIndex = index; }); } void _onItemTapped(int selectedIndex) { _pageController.jumpToPage(selectedIndex); } And then initialize! return Scaffold( body: PageView( controller: _pageController, children: _screen, onPageChanged: _onPageChanged, physics: NeverScrollableScrollPhysics(), ), Once you've made the appropriate changes to your code, save main.dart, open a terminal to the tg_flutter folder and run flutter run -d chrome`. A Chrome browser will automatically open and run assuming there are no errors. Here you will find the web application with the navigation bar. Here is the tutorial I watched to learn about the implementation of a Navbar in Flutter. The tutorial also gives more information about page persistence. I will not explain the exact implementation, but the please watch the tutorial as it is very helpful! And reference the code provided in the repo. Side Note: After you make changes to your main.dart file, if you hit r in the terminal that the terminal the flutter app is running from, it will hot restart the changes you made while the app is still running! The browser will just reload and your changes should appear as long as there are no errors.","title":"Navigation"},{"location":"frontend_pages/06_adding/","text":"Let's begin adding content to our application and start off with something simple, adding a gif to our intro page! Find your favorite gif online, copy the url, and let's display it from the web. The following line of code is a network call to display images from a url string. Image.network('https://example.com/animated-image.gif') Below is the code I included in the body of my intro_page.dart to display a TigerGraph inspired gif! child: Image.network('https://media2.giphy.com/media/dv7LVj1t6e1wobkYgX/giphy.gif?cid=ecf05e47zs97ng6h05arjp3l73ti4g0wyqr191cgy19bqoa4&rid=giphy.gif&ct=g', width: 300, height: 400, fit: BoxFit.contain, ),","title":"Adding to the Intro Page"},{"location":"frontend_pages/07_tigergraph/","text":"Now for the meat and potatoes of the project. We have already added the HTTP dependency to our pubspec.yml file, so we should be good to integrate the GET requests! First import HTTP into product_page.dart and user_page.dart like so: import 'package:http/http.dart' as http; import 'dart:async'; import 'dart:convert'; Building a User Class Let's begin with getting our User information in user_page.dart . We must first create a User class to contain what is returned from our userExists endpoint. class User { final bool success; User({ required this.success, }); factory User.fromJson(Map<String, dynamic> json) { return User( success: json['res'], ); } } Function Call Then, a function must be created to call the userExists endpoint within the _UserPageState class. Future<User> _userExists() async { final url = 'http://127.0.0.1:8000/userExists?user=$id'; final response = await http.get(Uri.parse(url)); if (response.statusCode == 200) { return User.fromJson(jsonDecode(response.body)); } else { throw Exception('Failed to load user'); } } Text Controllers Create some text controllers and variablesto get live changes to the inputs. TextEditingController idController = TextEditingController(); String id = \"\"; String _idString = 'Your user will appear here if it exists! '; bool isVisible = false; Update Widgets and their Containers In the body of our main widget, we will be including three Containers. These are nested in the body as a list of 'children'. body: Padding( padding: EdgeInsets.all(10), child: ListView(children: The first container is for the 'User Search' text above the search box. Container( alignment: Alignment.center, padding: const EdgeInsets.all(10), margin: const EdgeInsets.only(top: 50), child: const Text( 'User Search', style: TextStyle( color: Colors.orange, fontWeight: FontWeight.w500, fontSize: 30), )), The second container is for the actual search box that contains our text controller for our input. This is where the user of the application will search for a user name in our data to see if it exists. Container( padding: EdgeInsets.only(top: 10, left: 150, right: 150, bottom: 10), child: TextField( controller: idController, decoration: InputDecoration( border: OutlineInputBorder(), labelText: 'User ID', ), ), ), Now the next container will add the functionality of a user searching the input and populate with the response from the endpoint call. The below code does the following within the controller: set stat with our user id input text on button press, call our _userExists function, set our return string to input text IF the _userExists function returns the proper result, or else let the user of the application know that they did not input a user id that exists, update the input boxes. Container( height: 50, padding: EdgeInsets.only( top: 0, left: 150, right: 150, bottom: 10), child: RaisedButton( textColor: Colors.white, color: Colors.orange, child: Text('Search'), onPressed: () { print(idController.text); setState(() { id = idController.text; }); _userExists().then((result) { if (result.success) { print(\"SUCCESS\"); setState(() { _idString = idController.text; }); } else { setState(() { isVisible = true; _idString = \"The user you searched does not exist! Oops!\"; }); } }); }, )), The final container populates the text below the input box that follows 'User Name' with either the user name returned from the endpoint if it existed, or if a user name wasn't found, it will populate with a message letting the user know that the search was not successful. padding: const EdgeInsets.only( top: 0, left: 150, right: 150, bottom: 10), child: Column(children: [ Text( \"User Name: \" + _idString, style: const TextStyle(fontSize: 30), ), ]) ), Repeat for Recommender Endpoint It is a similar process for the other endpoints we have created, but there are some differences with the JSON parsing. The Recommender API call returns a list, so the JSON response must be handled differently. We must also create our Recommendation class a bit differently. Notive we have now included a toString method to handle the output of the instance of our new class. class Recommendation { final String id; final String name; final double avgRating; final int numRating; Recommendation( {required this.id, required this.name, required this.avgRating, required this.numRating}); factory Recommendation.fromJson(Map<String, dynamic> json) { return Recommendation( id: json['id'], name: json['name'], avgRating: json['average rating'], numRating: json['num rating']); } @override String toString() { return ''' Recommended ID: ${id} Product Name: ${name} Average Rating: ${avgRating} Number Rating: ${numRating} '''; } } The url response must be parsed and transformed into a list as well. Future<List<Recommendation>> _fetchRecommendations() async { final url = 'http://127.0.0.1:8000/recommender?user=$recommendedUser'; final response = await http.get(Uri.parse(url)); if (response.statusCode == 200) { var jsonResponse = json.decode(response.body)['children'] as List; return jsonResponse .map((recommendation) => Recommendation.fromJson(recommendation)) .toList(); } else { throw Exception('Failed to load recommendation'); } } And now to call the new _fetchRecommendations() function when our search button is pressed. onPressed: () { setState(() { recommendedUser = recommendationController.text; }); _fetchRecommendations().then((result) { // ignore: unnecessary_null_comparison if (result != null) { setState(() { _recommendationName = recommendationController.text; _recommendedProducts = result.join((\", \")).replaceAll(\",\", \"\"); }); } else { setState(() { isVisible = true; }); } }); }, ) JSON Resources and Sample Input JSON parsing in Flutter was the most difficult concept for me to grasp, so below are a few resources that helped me understand it better: Background Parsing Dart Flutter Parse JSON String Array to Object List Now follow the code provided to add the product search and product recommendation for the product page.","title":"TigerGraph Functionality"},{"location":"frontend_pages/07_tigergraph/#building-a-user-class","text":"Let's begin with getting our User information in user_page.dart . We must first create a User class to contain what is returned from our userExists endpoint. class User { final bool success; User({ required this.success, }); factory User.fromJson(Map<String, dynamic> json) { return User( success: json['res'], ); } }","title":"Building a User Class"},{"location":"frontend_pages/07_tigergraph/#function-call","text":"Then, a function must be created to call the userExists endpoint within the _UserPageState class. Future<User> _userExists() async { final url = 'http://127.0.0.1:8000/userExists?user=$id'; final response = await http.get(Uri.parse(url)); if (response.statusCode == 200) { return User.fromJson(jsonDecode(response.body)); } else { throw Exception('Failed to load user'); } }","title":"Function Call"},{"location":"frontend_pages/07_tigergraph/#text-controllers","text":"Create some text controllers and variablesto get live changes to the inputs. TextEditingController idController = TextEditingController(); String id = \"\"; String _idString = 'Your user will appear here if it exists! '; bool isVisible = false;","title":"Text Controllers"},{"location":"frontend_pages/07_tigergraph/#update-widgets-and-their-containers","text":"In the body of our main widget, we will be including three Containers. These are nested in the body as a list of 'children'. body: Padding( padding: EdgeInsets.all(10), child: ListView(children: The first container is for the 'User Search' text above the search box. Container( alignment: Alignment.center, padding: const EdgeInsets.all(10), margin: const EdgeInsets.only(top: 50), child: const Text( 'User Search', style: TextStyle( color: Colors.orange, fontWeight: FontWeight.w500, fontSize: 30), )), The second container is for the actual search box that contains our text controller for our input. This is where the user of the application will search for a user name in our data to see if it exists. Container( padding: EdgeInsets.only(top: 10, left: 150, right: 150, bottom: 10), child: TextField( controller: idController, decoration: InputDecoration( border: OutlineInputBorder(), labelText: 'User ID', ), ), ), Now the next container will add the functionality of a user searching the input and populate with the response from the endpoint call. The below code does the following within the controller: set stat with our user id input text on button press, call our _userExists function, set our return string to input text IF the _userExists function returns the proper result, or else let the user of the application know that they did not input a user id that exists, update the input boxes. Container( height: 50, padding: EdgeInsets.only( top: 0, left: 150, right: 150, bottom: 10), child: RaisedButton( textColor: Colors.white, color: Colors.orange, child: Text('Search'), onPressed: () { print(idController.text); setState(() { id = idController.text; }); _userExists().then((result) { if (result.success) { print(\"SUCCESS\"); setState(() { _idString = idController.text; }); } else { setState(() { isVisible = true; _idString = \"The user you searched does not exist! Oops!\"; }); } }); }, )), The final container populates the text below the input box that follows 'User Name' with either the user name returned from the endpoint if it existed, or if a user name wasn't found, it will populate with a message letting the user know that the search was not successful. padding: const EdgeInsets.only( top: 0, left: 150, right: 150, bottom: 10), child: Column(children: [ Text( \"User Name: \" + _idString, style: const TextStyle(fontSize: 30), ), ]) ),","title":"Update Widgets and their Containers"},{"location":"frontend_pages/07_tigergraph/#repeat-for-recommender-endpoint","text":"It is a similar process for the other endpoints we have created, but there are some differences with the JSON parsing. The Recommender API call returns a list, so the JSON response must be handled differently. We must also create our Recommendation class a bit differently. Notive we have now included a toString method to handle the output of the instance of our new class. class Recommendation { final String id; final String name; final double avgRating; final int numRating; Recommendation( {required this.id, required this.name, required this.avgRating, required this.numRating}); factory Recommendation.fromJson(Map<String, dynamic> json) { return Recommendation( id: json['id'], name: json['name'], avgRating: json['average rating'], numRating: json['num rating']); } @override String toString() { return ''' Recommended ID: ${id} Product Name: ${name} Average Rating: ${avgRating} Number Rating: ${numRating} '''; } } The url response must be parsed and transformed into a list as well. Future<List<Recommendation>> _fetchRecommendations() async { final url = 'http://127.0.0.1:8000/recommender?user=$recommendedUser'; final response = await http.get(Uri.parse(url)); if (response.statusCode == 200) { var jsonResponse = json.decode(response.body)['children'] as List; return jsonResponse .map((recommendation) => Recommendation.fromJson(recommendation)) .toList(); } else { throw Exception('Failed to load recommendation'); } } And now to call the new _fetchRecommendations() function when our search button is pressed. onPressed: () { setState(() { recommendedUser = recommendationController.text; }); _fetchRecommendations().then((result) { // ignore: unnecessary_null_comparison if (result != null) { setState(() { _recommendationName = recommendationController.text; _recommendedProducts = result.join((\", \")).replaceAll(\",\", \"\"); }); } else { setState(() { isVisible = true; }); } }); }, )","title":"Repeat for Recommender Endpoint"},{"location":"frontend_pages/07_tigergraph/#json-resources-and-sample-input","text":"JSON parsing in Flutter was the most difficult concept for me to grasp, so below are a few resources that helped me understand it better: Background Parsing Dart Flutter Parse JSON String Array to Object List Now follow the code provided to add the product search and product recommendation for the product page.","title":"JSON Resources and Sample Input"}]}